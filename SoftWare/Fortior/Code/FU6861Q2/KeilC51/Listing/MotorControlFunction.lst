C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              04/01/2023 22:13:42 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MOTORCONTROLFUNCTION
OBJECT MODULE PLACED IN .\Output\MotorControlFunction.obj
COMPILER INVOKED BY: D:\IDE\keil\C51\BIN\C51.EXE ..\User\Source\Function\MotorControlFunction.c LARGE OMF2 WARNINGLEVEL(
                    -0) BROWSE INCDIR(..\User\Include;..\FU68xx_Hardware_Driver\Include) DEBUG PRINT(.\Listing\MotorControlFunction.lst) TABS
                    -(2) OBJECT(.\Output\MotorControlFunction.obj)

line level    source

   1          /**
   2           * @copyright (C) COPYRIGHT 2022 Fortiortech Shenzhen
   3           * @file      MotorControlFunction.c
   4           * @author    Fortiortech  Appliction Team
   5           * @since     Create:2021-11-07
   6           * @date      Last modify:2022-07-14
   7           * @brief    
   8           */
   9          
  10          #include <FU68xx_2.h>
  11          #include <Myproject.h>
  12          
  13          
  14          RPD_TypeDef             xdata   RPD_Status;
  15          RPD_Param_TypeDef       xdata   RPDPara;
  16          MotorTailWindTypeDef    xdata   TailWindDetect;
  17          BEMFDetect_TypeDef      xdata   BEMFDetect;
  18          CurrentOffset           xdata   mcCurOffset;
  19          
  20          /** 
  21           * @brief      å¯¹FOCçš„ç›¸å…³å¯„å­˜å™¨è¿›è¡Œé…ç½®,å…ˆæ¸…ç†å¯„å­˜å™¨ï¼Œåé…ç½®ï¼Œæœ€åä½¿èƒ½
  22           * @exception  åˆå§‹åŒ–FOCï¼Œéœ€è¦å…ˆå…³é—­DRVIVERï¼Œå¯¹FOCå¯„å­˜å™¨é…ç½®å®Œæˆåï¼Œä½¿èƒ½FOCå†æ‰“å¼€
             -DRVIVER,å¦åˆ™å¯èƒ½å¯¼è‡´ç¬¬ä¸€æ‹ç”µæµé‡‡æ ·é”™è¯¯
  23           */
  24          void FOC_Init(void)
  25          {
  26   1          /* -----ä½¿èƒ½FOC ----- */
  27   1          ClrBit(DRV_CR, FOCEN);
  28   1          SetBit(DRV_CR, FOCEN);
  29   1          /* -----é…ç½®FOCå¯„å­˜å™¨ ----- */
  30   1          FOC_CR1         = 0;                                                                            // æ¸…
             -é›¶ FOC_CR1
  31   1          FOC_CR2         = 0;                                                                            // æ¸…
             -é›¶ FOC_CR2
  32   1          FOC_IDREF       = 0;                                                                            // æ¸…
             -é›¶ Id
  33   1          FOC_IQREF       = 0;                                                                            // æ¸…
             -é›¶ Iq
  34   1          FOC__THETA      = 0;                                                                            // æ¸…
             -é›¶ è§’åº¦
  35   1          FOC_RTHEACC     = 0;                                                                            // æ¸…
             -é›¶ çˆ¬å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
  36   1          FOC__RTHESTEP   = 0;                                                                            //
  37   1          FOC__RTHECNT    = 0;                                                                            //
  38   1          FOC_THECOMP    = _Q15(0.0 / 180.0);                                                            // SMO 
             -ä¼°ç®—è¡¥å¿è§’
  39   1          FOC_THECOR         = 0x04;                                                                     // è¯¯å
             -·®è§’åº¦è¡¥å¿
  40   1          #if (FG_Enable==1)
                  FOC_KFG         = FG_Value;
                  #endif
  43   1          //      SetBit(FOC_CR2, UQD);
  44   1          //    SetBit(FOC_CR2, UDD);
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              04/01/2023 22:13:42 PAGE 2   

  45   1          /* -----ç”µæµç¯å‚æ•°é…ç½® ----- */
  46   1          FOC_DMAX            = DOUTMAX;
  47   1          FOC_DMIN            = DOUTMIN;
  48   1          FOC_QMAX            = QOUTMAX;
  49   1          FOC_QMIN            = QOUTMIN;
  50   1          /* -----ä½ç½®ä¼°ç®—å‚æ•°é…ç½® ----- */
  51   1          FOC_EK1             = OBS_K1T;
  52   1          FOC_EK2             = OBS_K2T;
  53   1          FOC_EK3             = OBS_K3T;
  54   1          FOC_EK4             = OBS_K4T;
  55   1      
  56   1          #if (EstimateAlgorithm == AO)// è‡ªé€‚åº”ä¼°ç®—å™¨æ¨¡å¼ä½¿èƒ½
  57   1          {
  58   2              SetBit(FOC_CR3, ESCMS);
  59   2              SetBit(FOC_CR3, MFP_EN);
  60   2              ClrBit(FOC_CR2, ESEL);
  61   2              FOC_EKLPFMIN    = OBS_EA_KS;
  62   2          }
  63   1          #elif (EstimateAlgorithm == SMO)
                  {
                      ClrBit(FOC_CR2, ESEL);
                      FOC_KSLIDE    = OBS_KSLIDE;
                      FOC_EKLPFMIN    = OBS_EA_KS;
                  }
                  #elif (EstimateAlgorithm == PLL)
                  {
                      SetBit(FOC_CR2, ESEL);
                      FOC_KSLIDE      = OBSE_PLLKP_GAIN;
                      FOC_EKLPFMIN    = OBSE_PLLKI_GAIN;
                  }
                  #else
                  {
                      #error " EstimateAlgorithm  ERR"
                  }
                  #endif    
  80   1          
  81   1          FOC_FBASE           = OBS_FBASE;
  82   1          FOC_OMEKLPF         = SPEED_KLPF;
  83   1          FOC_EBMFK           = OBS_KLPF;
  84   1          FOC_TGLI            = PWM_TGLI_LOAD;
  85   1      
  86   1          SetBit(FOC_CR1, SVPWMEN);                                                                       // SVP
             -WMæ¨¡å¼
  87   1          //  /*æ­£åè½¬*/
  88   1          //  if(mcFRState.FR==1)                                                                         // è®¾
             -ç½®F/R
  89   1          //  {
  90   1          //    SetBit(DRV_CR,DRV_DDIR);
  91   1          //  }
  92   1          //  else
  93   1          //  {
  94   1          //    ClrBit(DRV_CR,DRV_DDIR);
  95   1          //  }
  96   1          #if (FRMODE==1)
  97   1          {
  98   2              SetBit(DRV_CR, DDIR);                                                                       // å
             -è½¬æ ‡å¿—ä½
  99   2          }
 100   1          #endif //end FRMODE
 101   1          /* -----è¿‡è°ƒåˆ¶ ----- */
 102   1          #if (OverModulation == 1)
                  {
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              04/01/2023 22:13:42 PAGE 3   

                      SetBit(FOC_CR1, OVMDL);                                                                     // è¿‡
             -è°ƒåˆ¶
                  }
                  #endif                                                                                          //end 
             -OverModulation
 107   1          /* -----å•ç”µé˜»é‡‡æ ·ï¼›éœ€è¦æœ€å°é‡‡æ ·çª—,FOC_TRGDLYä¸º0ï¼Œä¸ƒæ®µå¼SVPWMæ–¹å¼ ----- */
 108   1          #if (Shunt_Resistor_Mode == Single_Resistor)
 109   1          {
 110   2              SetReg(FOC_CR1, CSM0 | CSM1, 0x00);
 111   2              FOC_TRGDLY = 9;                                                                             // 0x0
             -cè¡¨ç¤ºå»¶è¿Ÿ12ä¸ªclockï¼Œæå‰ç”¨åç å½¢å¼ï¼Œå¦‚0x84è¡¨ç¤ºæå‰12ä¸ªclockã€‚
 112   2              ClrBit(FOC_CR2, F5SEG);                                                                     // 7æ®
             -µå¼
 113   2              SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, 0x00);
 114   2              /* -----æœ€å°çª—å£è®¾ç½®ï¼Œé˜²æ­¢æº¢å‡ºå¤„ç†----- */
 115   2              /* -----FOC_TSMIN éœ€è¦å°äºè½½æ³¢å‘¨æœŸçš„1/16 ----- */
 116   2              mcFaultDect.TempTSminValue =  PWM_TS_LOAD;
 117   2              
 118   2              if (mcFaultDect.TempTSminValue < 255)
 119   2              {
 120   3                  FOC_TSMIN = mcFaultDect.TempTSminValue;
 121   3              }
 122   2              else
 123   2              {
 124   3                  FOC_TSMIN = 255;
 125   3              }
 126   2          }
 127   1          /* -----åŒç”µé˜»é‡‡æ ·ï¼Œå¯è®¾ç½®æ­»åŒºè¡¥å¿å€¼ï¼Œåœ¨ä¸‹é™æ²¿ç»“æŸå‰å¼€å§‹é‡‡æ ·Iaï¼Œé…ç½®81 --
             ---- */
 128   1          #elif (Shunt_Resistor_Mode == Double_Resistor)                                                  
                  {
                      SetReg(FOC_CR1, CSM0 | CSM1, CSM0);
                      FOC_TSMIN = PWM_DT_LOAD;                                                                    // æ­»
             -åŒºè¡¥å¿å€¼
                      FOC_TRGDLY = 0x85;                                                                          // ADC
             -é‡‡æ ·çš„æ—¶åˆ»ï¼Œé‡‡æ ·æ—¶åˆ»åœ¨è®¡æ•°å™¨é›¶ç‚¹é™„è¿‘ï¼Œ83ä¸ºä¸‹é™æ²¿ç»“æŸå‰3ä¸ªclocké‡‡æ ·Iaï¼Œä¸å•ç”µé˜»ä¸åŒ
                      /* -----01ä¸ºä¸Šå‡æ²¿å¼€å§‹åç¬¬ä¸€ä¸ªclockå¼€å§‹é‡‡æ ·ã€‚æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ ----- */
                      FOC_TBLO = PWM_DLOWL_TIME;                                                                  //ä¸‹æ
             -¡¥è‡‚æœ€å°è„‰å†²ï¼Œä¿è¯é‡‡æ ·
                      SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, 0x00);
                      /* -----äº”æ®µå¼æˆ–ä¸ƒæ®µå¼é€‰æ‹© ----- */
                      #if (SVPMW_Mode == SVPWM_7_Segment)
                      {
                          ClrBit(FOC_CR2, F5SEG);
                      }
                      #elif (SVPMW_Mode == SVPWM_5_Segment)
                      {
                          SetBit(FOC_CR2, F5SEG);
                      }
                      #endif
                      #if (DouRes_Sample_Mode == DouRes_1_Cycle)
                      {
                          ClrBit(FOC_CR2, DSS);
                      }
                      #elif (DouRes_Sample_Mode == DouRes_2_Cycle)
                      {
                          SetBit(FOC_CR2, FOC_DSS);
                      }
                      #endif                                                                                    
                  }
                  /* -----ä¸‰ç”µé˜»é‡‡æ · ----- */
                  #elif (Shunt_Resistor_Mode == Three_Resistor)                                                   
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              04/01/2023 22:13:42 PAGE 4   

                  {
                      SetReg(FOC_CR1, CSM0 | CSM1, CSM0 | CSM1);// ä¸‰ç”µé˜»
                      FOC_TSMIN  = PWM_DT_LOAD;                                                                   // æ­»
             -åŒºè¡¥å¿å€¼
                      FOC_TRGDLY = 06;                                                                            // ADC
             -é‡‡æ ·çš„æ—¶åˆ»ï¼Œé‡‡æ ·æ—¶åˆ»åœ¨è®¡æ•°å™¨é›¶ç‚¹é™„è¿‘ï¼Œ83ä¸ºä¸‹é™æ²¿ç»“æŸå‰3ä¸ªclocké‡‡æ ·Iaï¼Œä¸å•ç”µé˜»ä¸åŒã€
             -‚
                      /* -----01ä¸ºä¸Šå‡æ²¿å¼€å§‹åç¬¬ä¸€ä¸ªclockå¼€å§‹é‡‡æ ·ã€‚æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ ----- */
                      SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, CMP3MOD0 | CMP3MOD1);
                      FOC_TBLO = PWM_OVERMODULE_TIME;                                                             // è¿‡
             -è°ƒåˆ¶ç”µæµé‡‡æ ·å¤„ç†çš„TBè„‰å®½
                      /* -----äº”æ®µå¼æˆ–ä¸ƒæ®µå¼é€‰æ‹© ----- */
                      #if (SVPMW_Mode == SVPWM_7_Segment)
                      {
                          ClrBit(FOC_CR2, F5SEG);
                      }
                      #elif (SVPMW_Mode == SVPWM_5_Segment)
                      {
                          SetBit(FOC_CR2, F5SEG);
                      }
                      #endif  
                      #if (DouRes_Sample_Mode == DouRes_1_Cycle)
                      {
                          ClrBit(FOC_CR2, DSS);
                      }
                      #elif (DouRes_Sample_Mode == DouRes_2_Cycle)
                      {
                          SetBit(FOC_CR2, DSS);
                      }
                      #endif                                                                                      
                  }
                  #endif                                                                                          
 186   1          /* -----ä½¿èƒ½ç”µæµåŸºå‡†æ ¡æ­£ ----- */
 187   1          #if (CalibENDIS == Enable)
 188   1          {
 189   2              if (mcCurOffset.OffsetFlag == 1)
 190   2              {
 191   3                  #if (Shunt_Resistor_Mode == Single_Resistor)                                            // å•
             -ç”µé˜»æ ¡æ­£
 192   3                  {
 193   4                      /* -----set ibus current sample offset ----- */
 194   4                      SetReg(FOC_CR2, CSOC0 | CSOC1, 0x00);
 195   4                      FOC_CSO = mcCurOffset.Iw_busOffset;                                                 // å†™
             -å…¥Ibusçš„åç½®
 196   4                      
 197   4                  }
 198   3                  #elif (Shunt_Resistor_Mode == Double_Resistor)                                          // åŒ
             -ç”µé˜»æ ¡æ­£
                          {
                              /* -----set ia, ib current sample offset ----- */
                              SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC0);
                              FOC_CSO  = mcCurOffset.IuOffset;                                                    // å†™
             -å…¥IAçš„åç½®
                          
                              SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC1);
                              FOC_CSO  = mcCurOffset.IvOffset;                                                    // å†™
             -å…¥IBçš„åç½®
                          
                          }
                          #elif (Shunt_Resistor_Mode == Three_Resistor)                                           // ä¸‰
             -ç”µé˜»æ ¡æ­£
                          {
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              04/01/2023 22:13:42 PAGE 5   

                              /* -----set ibus current sample offset ----- */
                              SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC0);
                              FOC_CSO = mcCurOffset.IuOffset;                                                     // å†™
             -å…¥IAçš„åç½®
                          
                              SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC1);
                              FOC_CSO = mcCurOffset.IvOffset;                                                     // å†™
             -å…¥IBçš„åç½®
                          
                              SetReg(FOC_CR2, CSOC0 | CSOC1, 0x00);
                              FOC_CSO = mcCurOffset.Iw_busOffset;                                                 // å†™
             -å…¥ICçš„åç½®
                          }
                          #endif                                                                                  //end 
             -Shunt_Resistor_Mode
 221   3              }
 222   2          }
 223   1          #endif                                                                                          //end 
             -CalibENDIS
 224   1          /*  -------------------------------------------------------------------------------------------------
 225   1              DRV_CTLï¼šPWMæ¥æºé€‰æ‹©
 226   1              OCS = 0, DRV_COMR
 227   1              OCS = 1, FOC/SVPWM/SPWM
 228   1              -------------------------------------------------------------------------------------------------*
             -/
 229   1          /* -----è®¡æ•°å™¨æ¯”è¾ƒå€¼æ¥æºFOC ----- */
 230   1          SetBit(DRV_CR, OCS);
 231   1      }
 232          
 233          
 234          /** 
 235           * @brief     é¢„å®šä½ï¼Œå¼€å¯æ­¤åŠŸèƒ½å¯åŠ¨æ—¶å€™ä¼šå°†ç”µæœºå¼ºæ‹‰åˆ°è®¾å®šè§’åº¦ï¼Œä¹‹åå†å¯åŠ¨
 236           */
 237          void Motor_Align(void)
 238          {
 239   1          if (McStaSet.SetFlag.AlignSetFlag == 0)
 240   1          {
 241   2              McStaSet.SetFlag.AlignSetFlag = 1;
 242   2              /* -----FOCåˆå§‹åŒ–----- */
 243   2              FOC_Init();
 244   2              /* -----é…ç½®é¢„å®šä½çš„ç”µæµã€KPã€KI----- */
 245   2              //        FOC_IDREF = ID_Align_CURRENT;
 246   2              //        FOC_IQREF = IQ_Align_CURRENT;
 247   2              //        FOC_DQKP = DQKP_Alignment;
 248   2              //        FOC_DQKI = DQKI_Alignment;
 249   2              FOC_EKP     = OBSW_KP_GAIN;
 250   2              FOC_EKI     = OBSW_KI_GAIN;
 251   2              SetBit(FOC_CR2, UQD);
 252   2              SetBit(FOC_CR2, UDD);
 253   2              #if (Align_Associated_Vol_EN == 0)
                      {
                          FOC__UQ = _Q15(0.0);
                          FOC__UD = UD_Duty;
                      }
                      #else
 259   2              {
 260   3                  /* -----å…³è”ç”µå‹ï¼Œä¿è¯æ‰€æœ‰ç”µå‹é¢„å®šä½åŠ›çŸ©è¶³å¤Ÿä¸”ä¸è¿‡å¤§----- */
 261   3                  mcFocCtrl.TempUDQValue = UD_K * (mcFocCtrl.mcDcbusFlt - UDMIN_Volt_VALUE) + UDMIN;
 262   3              
 263   3                  /* -----é˜²æ­¢UDQå®šä½å ç©ºæ¯”å¤ªå¤§----- */
 264   3                  if (mcFocCtrl.TempUDQValue < _Q15(0.1))
 265   3                  {
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              04/01/2023 22:13:42 PAGE 6   

 266   4                      FOC__UD =  mcFocCtrl.TempUDQValue;
 267   4                  }
 268   3                  else
 269   3                  {
 270   4                      FOC__UD =  _Q15(0.1);
 271   4                  }
 272   3              }
 273   2              #endif                                                                                      
 274   2              /* -----é…ç½®é¢„å®šä½è§’åº¦----- */
 275   2              #if (AlignTestMode==1)
                      {
                          FOC__THETA      = Align_Theta;
                      }
                      #else
 280   2              {
 281   3                  #if (PosCheckEnable==1)
                          {
                              FOC__THETA    = mcFocCtrl.mcPosCheckAngle;
                          }
                          #else
 286   3                  {
 287   4                      FOC__THETA      = Align_Theta;
 288   4                  }
 289   3                  #endif                                                                                  
 290   3              }
 291   2              #endif                                                                                       
 292   2              /* -----PLLæˆ–SMO----- */
 293   2              #if (EstimateAlgorithm == SMO  || EstimateAlgorithm == AO)
 294   2              {
 295   3                  FOC__ETHETA   = FOC__THETA - 4096;
 296   3              }
 297   2              #elif (EstimateAlgorithm == PLL)
                      {
                          FOC__ETHETA   = FOC__THETA;
                      }
                      #endif                                                                                    
 302   2              TimeCnt = FOC__THETA;
 303   2              /* -----ä½¿èƒ½è¾“å‡º----- */
 304   2              DRV_CMR |= 0x3F;                                                                            // Uã€
             -Vã€Wç›¸è¾“å‡º
 305   2              MOE = 1;
 306   2          }
 307   1      }
 308          
 309          
 310          /** 
 311           * @brief     é™æ­¢å¯åŠ¨é…ç½®å‡½æ•°
 312           */
 313          void Motor_Open(void)
 314          {
 315   1           #if (AlignTestMode==0)
 316   1          {
 317   2              DRV_CMR |= 0x3F;                                                                            // Uã€
             -Vã€Wç›¸è¾“å‡º
 318   2              MOE = 1;
 319   2          }
 320   1          #endif
 321   1          #if (Open_Start_Mode == Open_Start)
                  {
                      static uint8 OpenRampCycles;                                                                // å¦
             -åˆ™å®šä¹‰äº†æ²¡è°ƒç”¨ï¼Œlintä¼šæŠ¥è­¦å‘Š
                  }
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              04/01/2023 22:13:42 PAGE 7   

                  #endif
 326   1          
 327   1          if (McStaSet.SetFlag.StartSetFlag == 0)
 328   1          {
 329   2              McStaSet.SetFlag.StartSetFlag = 1;
 330   2              /* -----å¯åŠ¨åˆå§‹è§’åº¦èµ‹å€¼----- */
 331   2              #if (PosCheckEnable)
                      {
                          FOC__THETA  = mcFocCtrl.mcPosCheckAngle;                                                // æœ‰
             -åˆå§‹ä½ç½®æ£€æµ‹ï¼Œåˆ™ç”¨åˆå§‹ä½ç½®è§’
                      }
                      #else
 336   2              {
 337   3                  FOC__THETA  = Align_Theta;                                                              // æ— 
             -åˆå§‹ä½ç½®æ£€æµ‹ï¼Œåˆ™ç”¨é¢„å®šä½è§’
 338   3              }
 339   2              #endif
 340   2              /* -----PLLæˆ–SMO----- */
 341   2              #if (EstimateAlgorithm == SMO  || EstimateAlgorithm == AO)
 342   2              {
 343   3                  FOC__ETHETA = FOC__THETA - 4915;
 344   3              }
 345   2              #elif (EstimateAlgorithm == PLL)
                      {
                          FOC__ETHETA = FOC__THETA;
                      }
                      #endif                                                                                      
 350   2              TimeCnt = FOC__ETHETA;                                                                 
 351   2              /* -----å¯åŠ¨ç”µæµã€KPã€KIã€FOC_EKPã€FOC_EKI----- */
 352   2              FOC_IDREF = ID_Start_CURRENT;                                                               // Dè½
             -´å¯åŠ¨ç”µæµ
 353   2              mcFocCtrl.mcIqref = IQ_Start_CURRENT;                                                       // Qè½
             -´å¯åŠ¨ç”µæµ
 354   2              #if (TailWind_Mode==BEMFMethod)
 355   2              {
 356   3                  if (BEMFDetect.BEMFCCWFlag == 1)
 357   3                  {
 358   4                      mcFocCtrl.mcIqref += I_Value(0.95);                                                 // é€†
             -é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
 359   4                  }
 360   3                  else if (BEMFDetect.BEMFCCWFlag == 2)
 361   3                  {
 362   4                      mcFocCtrl.mcIqref += I_Value(0.8);                                                  // é€†
             -é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
 363   4                  }
 364   3              }
 365   2              #elif (TailWind_Mode==RSDMethod)
                      {
                          if ((RSDDetect.RSDCCWFlag == 1) || (RSDDetect.RSDCCWTimes >= 4))
                          {
                              mcFocCtrl.mcIqref += I_Value(0.95);                                                 // é€†
             -é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
                          }
                          else if (RSDDetect.RSDCCWFlag == 2)
                          {
                              mcFocCtrl.mcIqref += I_Value(0.9);                                                  // é€†
             -é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
                          }
                      }
                      #endif
 377   2              FOC_DQKP    = DQKPStart;
 378   2              FOC_DQKI    = DQKIStart;
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              04/01/2023 22:13:42 PAGE 8   

 379   2              FOC_EKP     = OBSW_KP_GAIN;
 380   2              FOC_EKI     = OBSW_KI_GAIN;
 381   2              /* -----å¯åŠ¨æ–¹å¼é€‰æ‹©----- */
 382   2              #if (Open_Start_Mode == Omega_Start)                                                        // Ome
             -ga å¯åŠ¨
 383   2              {
 384   3                  FOC_EFREQACC    = Motor_Omega_Ramp_ACC;
 385   3                  FOC_EFREQMIN    = Motor_Omega_Ramp_Min;
 386   3                  FOC_EFREQHOLD   = Motor_Omega_Ramp_End;
 387   3                  SetBit(FOC_CR1, EFAE);                                                                  // ä¼°
             -ç®—å™¨å¼ºåˆ¶è¾“å‡º
 388   3                  ClrBit(FOC_CR1, RFAE);                                                                  // ç¦
             -æ­¢å¼ºæ‹‰
 389   3                  SetBit(FOC_CR1, ANGM);                                                                  // ä¼°
             -ç®—æ¨¡å¼
 390   3              }
 391   2              #elif (Open_Start_Mode == Open_Start)
                      {
                          FOC_RTHEACC     = Motor_Open_Ramp_ACC;                                                  // çˆ¬
             -å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
                          FOC__RTHESTEP   = Motor_Open_Ramp_Min;                                                  // 0.6
             -2 degree acce speed
                          RPDPara.ThetaGet = Motor_Open_Ramp_Min;
                          FOC__RTHECNT    = MOTOR_OPEN_ACC_CNT;                                                   // acc
             -e time
                          ClrBit(FOC_CR1, EFAE);                                                                  // ä¼°
             -ç®—å™¨å¼ºåˆ¶è¾“å‡º
                          SetBit(FOC_CR1, RFAE);                                                                  // ç¦
             -æ­¢å¼ºæ‹‰
                          ClrBit(FOC_CR1, ANGM);                                                                  // ä¼°
             -ç®—æ¨¡å¼
                      }
                      #elif (Open_Start_Mode == Open_Omega_Start)
                      {
                          FOC_RTHEACC     = Motor_Open_Ramp_ACC;                                                  // çˆ¬
             -å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
                          FOC__RTHESTEP   = Motor_Open_Ramp_Min;                                                  // 0.6
             -2 degree acce speed
                          FOC__RTHECNT    = MOTOR_OPEN_ACC_CNT;                                                   // acc
             -e time
                          FOC_EFREQACC    = Motor_Omega_Ramp_ACC;
                          FOC_EFREQMIN    = Motor_Omega_Ramp_Min;
                          FOC_EFREQHOLD   = Motor_Omega_Ramp_End;
                          SetBit(FOC_CR1, EFAE);                                                                  // ä¼°
             -ç®—å™¨å¼ºåˆ¶è¾“å‡º
                          SetBit(FOC_CR1, RFAE);                                                                  // ç¦
             -æ­¢å¼ºæ‹‰
                          SetBit(FOC_CR1, ANGM);                                                                  // ä¼°
             -ç®—æ¨¡å¼
                      }
                      #endif                                                                                     
 414   2          }
 415   1          
 416   1          /* -----ä¸åŒå¯åŠ¨æ–¹å¼ä¸‹ï¼Œåˆ‡æ¢åˆ°MCRUNçŠ¶æ€----- */
 417   1          #if (Open_Start_Mode == Open_Start)                                                             //OPEN
             -çŠ¶æ€å¯åŠ¨æ—¶æ‹–åŠ¨å¤šæ¬¡
                  {
                      
                      mcFocCtrl.State_Count = 20;                                                              
                      FOC_EKP = OBSW_KP_GAIN_RUN4;                                                                // ä¼°
             -ç®—å™¨é‡Œçš„PIçš„KP
                      FOC_EKI = OBSW_KI_GAIN_RUN4;                                                                // ä¼°
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              04/01/2023 22:13:42 PAGE 9   

             -ç®—å™¨é‡Œçš„PIçš„KI
                  }
                  #elif (Open_Start_Mode == Open_Omega_Start)
                  {
                      mcFocCtrl.State_Count = 2500;   //å•ä½ï¼š1ms
                      
                  }
                  #elif (Open_Start_Mode == Omega_Start)
 430   1          {
 431   2              /* -----PLLæˆ–SMO----- */
 432   2              #if (EstimateAlgorithm == SMO  || EstimateAlgorithm == AO)
 433   2              {
 434   3                  mcFocCtrl.State_Count = 700;    //å•ä½ï¼š1ms
 435   3              }
 436   2              #elif (EstimateAlgorithm == PLL)
                      {
                          mcFocCtrl.State_Count = 1400;    //å•ä½ï¼š1ms
                          FOC_EKP = OBSW_KP_GAIN_RUN1;                                                            // ä¼°
             -ç®—å™¨é‡Œçš„PIçš„KP
                          FOC_EKI = OBSW_KI_GAIN_RUN1;                                                            // ä¼°
             -ç®—å™¨é‡Œçš„PIçš„KI
                      }
                      #endif                                                                                      
 443   2              
 444   2          }
 445   1          #endif                                             
 446   1          LowSpeedObserverInit();
 447   1          FOC_IQREF = mcFocCtrl.mcIqref;                                                                  // Qè½
             -´å¯åŠ¨ç”µæµ
 448   1      }
 449          
 450          
 451          /** 
 452           * @brief     é¡ºé£é€†é£å‚æ•°é…ç½®å‡½æ•°
 453           */
 454          void Motor_TailWind(void)
 455          {
 456   1          if (mcFocCtrl.State_Count == 0)
 457   1          {
 458   2              if (McStaSet.SetFlag.TailWindSetFlag  == 0)                                                 //åˆå
             -§‹åŒ–
 459   2              {
 460   3                  McStaSet.SetFlag.TailWindSetFlag = 1;
 461   3                  #if (TailWind_Mode==RSDMethod)
                          {
                              RSDDetectInit();
                          }
                          #elif (TailWind_Mode==BEMFMethod)
 466   3                  {
 467   4                      BEMFDetectInit();
 468   4                  }
 469   3                  #endif
 470   3              }
 471   2              
 472   2              if (McStaSet.SetFlag.TailWindSetFlag == 1)
 473   2              {
 474   3                  #if (TailWind_Mode==RSDMethod)
                          {
                              RSDDealwith();
                          }
                          #elif (TailWind_Mode==BEMFMethod)
 479   3                  {
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              04/01/2023 22:13:42 PAGE 10  

 480   4                      BEMFDealwith();
 481   4                  }
 482   3                  #endif
 483   3              }
 484   2          }
 485   1      }
 486          
 487          /**
 488           * @brief    ç¬¬ä¸€æ¬¡ä¸Šç”µåˆå§‹åŒ–å˜é‡
 489           */
 490          void MotorcontrolInit(void)
 491          {
 492   1          /* -----ç”µæœºç›®æ ‡æ–¹å‘----- */
 493   1          mcFRState.TargetFR                 = (uint8)(FRMODE);
 494   1          /* -----ç”µæµåç½®æ ¡å‡†å˜é‡----- */
 495   1          mcCurOffset.IuOffsetSum            = 16383;
 496   1          mcCurOffset.IvOffsetSum            = 16383;
 497   1          mcCurOffset.Iw_busOffsetSum        = 16383;
 498   1          /* -----LEDç¯å“åº”----- */
 499   1          mcLedDisplay.Counttime             = 4999;
 500   1          /* -----é€Ÿåº¦ç¯çš„å“åº”----- */
 501   1          mcSpeedRamp.DelayPeriod           = 10;
 502   1      }
 503          
 504          
 505          /** 
 506           * @brief     åˆå§‹åŒ–ç”µæœºå‚æ•°ï¼Œæ¯æ¬¡ç”µæœºé‡å¯å‡ä¼šè¢«è°ƒç”¨
 507           * @warning   éœ€è¦æ³¨æ„å¡«å†™çš„å˜é‡æ˜¯å¦å¯ä»¥åœ¨æ­¤æ—¶åˆ»è¢«åˆå§‹åŒ–
 508           */
 509          void VariablesPreInit(void)
 510          {
 511   1          /* -----ä¿æŠ¤----- */
 512   1          mcFaultSource = 0;
 513   1          memset(&mcFaultDect, 0, sizeof(FaultVarible));                                                  // Fau
             -ltVaribleå˜é‡æ¸…é›¶
 514   1          /* -----å¤–éƒ¨æ§åˆ¶ç¯----- */
 515   1          memset(&mcFocCtrl, 0, sizeof(FOCCTRL));                                                         // mcF
             -ocCtrlå˜é‡æ¸…é›¶
 516   1          /* -----é¡ºé€†é£åˆ¤æ–­----- */
 517   1          #if (TailWind_Mode==RSDMethod)
                  {
                      RSDDetect.RSDCCWTimes    = 0;                                                               //  CC
             -Wåˆ¹è½¦æ¬¡æ•°æ¸…é›¶
                  }
                  #elif (TailWind_Mode==BEMFMethod)
 522   1          {
 523   2          }
 524   1          #elif (TailWind_Mode==FOCMethod)
                  {
                      memset(&TailWindDetect, 0, sizeof(MotorTailWindTypeDef));                                   //  Ta
             -ilWindDetectæ‰€æœ‰å˜é‡æ¸…é›¶
                  }
                  #endif
 529   1          /* -----ç”µæœºçŠ¶æ€æœºæ—¶åºå˜é‡----- */
 530   1          McStaSet.SetMode                   = 0;
 531   1          /* -----LEDç¯å“åº”----- */
 532   1          memset(&mcLedDisplay, 0, sizeof(MCLedDisplay));                                                 // mcL
             -edDisplayå˜é‡æ¸…é›¶
 533   1          mcLedDisplay.Counttime            = 4999;
 534   1          /* -----ç”µæœºåŠŸç‡å‚æ•°åˆå§‹åŒ–----- */
 535   1          Power_Currt                         = 0;
 536   1      }
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              04/01/2023 22:13:42 PAGE 11  

 537          
 538          
 539          /** 
 540           * @brief     ä¸Šç”µæ—¶ï¼Œå…ˆå¯¹ç¡¬ä»¶ç”µè·¯çš„ç”µæµè¿›è¡Œé‡‡é›†ï¼Œå†™å…¥å¯¹åº”çš„æ ¡å‡†å¯„å­˜å™¨ä¸­ã€‚
 541                        è°ƒè¯•æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffsetç»“æ„ä½“ä¸­å¯¹åº”å˜é‡æ˜¯å¦åœ¨èŒƒå›´å†…ã€‚é‡‡é›†ç»“æŸå
             -ï¼ŒOffsetFlagç½®1ã€‚
 542           */
 543          void GetCurrentOffset(void)
 544          {
 545   1          if (mcCurOffset.OffsetFlag == 0)
 546   1          {
 547   2              SetBit(ADC_CR, ADCBSY);                                                                     // ä½¿
             -èƒ½ADC
 548   2              
 549   2              while (ReadBit(ADC_CR, ADCBSY));
 550   2              
 551   2              #if (Shunt_Resistor_Mode == Single_Resistor)                                                // å•
             -ç”µé˜»æ¨¡å¼ï¼Œä¸Šç”µéªŒè¯ç¡¬ä»¶ç”µè·¯æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffset.IbusOffsetæ˜¯å¦ä¸º4096
 552   2              {
 553   3                  mcCurOffset.Iw_busOffsetSum += ((ADC4_DR & 0x0fff) << 3);
 554   3                  mcCurOffset.Iw_busOffset = mcCurOffset.Iw_busOffsetSum >> 4;
 555   3                  mcCurOffset.Iw_busOffsetSum -= mcCurOffset.Iw_busOffset;
 556   3              }
 557   2              #elif (Shunt_Resistor_Mode == Double_Resistor)                                              // åŒ
             -ç”µé˜»æ¨¡å¼ï¼Œä¸Šç”µéªŒè¯ç¡¬ä»¶ç”µè·¯æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffset.IaOffsetã€mcCurOffset.IbOffsetæ˜¯å¦ä¸º4096
                      {
                          mcCurOffset.IuOffsetSum += ((ADC0_DR & 0x0fff) << 3);
                          mcCurOffset.IuOffset = mcCurOffset.IuOffsetSum >> 4;
                          mcCurOffset.IuOffsetSum -= mcCurOffset.IuOffset;
                          mcCurOffset.IvOffsetSum += ((ADC1_DR & 0x0fff) << 3);
                          mcCurOffset.IvOffset = mcCurOffset.IvOffsetSum >> 4;
                          mcCurOffset.IvOffsetSum -= mcCurOffset.IvOffset;
                      }
                      #elif (Shunt_Resistor_Mode == Three_Resistor)                                               // ä¸‰
             -ç”µé˜»æ¨¡å¼ï¼Œä¸Šç”µéªŒè¯ç¡¬ä»¶ç”µè·¯æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffset.IaOffsetã€mcCurOffset.IbOffsetã€mcCurOffset.IcOffset
             -æ˜¯å¦ä¸º4096
                      {
                          mcCurOffset.IuOffsetSum += ((ADC0_DR & 0x0fff) << 3);
                          mcCurOffset.IuOffset = mcCurOffset.IuOffsetSum >> 4;
                          mcCurOffset.IuOffsetSum -= mcCurOffset.IuOffset;
                          mcCurOffset.IvOffsetSum += ((ADC1_DR & 0x0fff) << 3);
                          mcCurOffset.IvOffset = mcCurOffset.IvOffsetSum >> 4;
                          mcCurOffset.IvOffsetSum -= mcCurOffset.IvOffset;
                          mcCurOffset.Iw_busOffsetSum += ((ADC4_DR & 0x0fff) << 3);
                          mcCurOffset.Iw_busOffset = mcCurOffset.Iw_busOffsetSum >> 4;
                          mcCurOffset.Iw_busOffsetSum -= mcCurOffset.Iw_busOffset;
                      }
                      #endif
 579   2              mcCurOffset.OffsetCount++;
 580   2              
 581   2              if (mcCurOffset.OffsetCount > Calib_Time)
 582   2              {
 583   3                  mcCurOffset.OffsetFlag = 1;
 584   3                  #if (GetCurrentOffsetEnable)
                          {
                            Fault_GetCurrentOffset();                                                             // å
             -ç½®ç”µå‹ä¿æŠ¤
                          }
                          #endif
 589   3              }
 590   2          }
 591   1      }
C51 COMPILER V9.52.0.0   MOTORCONTROLFUNCTION                                              04/01/2023 22:13:42 PAGE 12  

 592          
 593          /** 
 594           * @brief     å…³é—­è¾“å‡ºï¼Œå…³é—­FOCï¼Œç”µæœºåˆ‡æ¢åˆ°mcReadyçŠ¶æ€è¢«è°ƒç”¨ä¸€æ¬¡
 595           */
 596          void Motor_Ready(void)
 597          {
 598   1          if (McStaSet.SetFlag.CalibFlag == 0)
 599   1          {
 600   2              McStaSet.SetFlag.CalibFlag = 1;
 601   2              MOE            = 0;                                                                         // å…³
             -é—­MOE
 602   2              ClrBit(DRV_CR, FOCEN);                                                                      // å…³
             -é—­FOC     
 603   2              SetBit(ADC_MASK_SYSC, CH7EN | CH4EN | CH3EN | CH2EN | CH1EN | CH0EN);                       // å¼€
             -å¯ADC        
 604   2          }
 605   1      }
 606          
 607          
 608          /** 
 609           * @brief     ç”µæœºåˆå§‹åŒ–ï¼Œå¯¹ç”µæœºç›¸å…³å˜é‡ã€PIè¿›è¡Œåˆå§‹åŒ–è®¾ç½®,å…³é—­FOCæ‰€éœ€è¦ä½¿ç”¨åˆ
             -°çš„ADC
 610           * @note      å…³é—­FOCæ‰€éœ€è¦ä½¿ç”¨åˆ°çš„ADCï¼ŒFOCæ¨¡å—ä¼šè‡ªåŠ¨è°ƒç”¨ç›¸åº”ADC æ— éœ€å¤–éƒ¨ä½¿èƒ½
 611           */
 612          void Motor_Init(void)
 613          {
 614   1          ClrBit(ADC_MASK_SYSC, CH4EN |  CH1EN | CH0EN);                                                  // å…³
             -é—­è½¯ä»¶ç”µæµé‡‡æ ·çš„ADC
 615   1          VariablesPreInit();                                                                             // ç”µ
             -æœºç›¸å…³å˜é‡åˆå§‹åŒ–
 616   1          PI_Init();                                                                                      // PIå
             -ˆå§‹åŒ–
 617   1          SpeedPIDInit();
 618   1          McStaSet.SetFlag.TailWindSetFlag = 0;
 619   1      }
 620          
 621          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1176    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    121    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
