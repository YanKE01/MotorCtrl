C51 COMPILER V9.52.0.0   UART                                                              04/01/2023 22:13:45 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Output\UART.obj
COMPILER INVOKED BY: D:\IDE\keil\C51\BIN\C51.EXE ..\User\Source\Hardware\UART.c LARGE OMF2 WARNINGLEVEL(0) BROWSE INCDIR
                    -(..\User\Include;..\FU68xx_Hardware_Driver\Include) DEBUG PRINT(.\Listing\UART.lst) TABS(2) OBJECT(.\Output\UART.obj)

line level    source

   1          /**
   2           * @copyright (C) COPYRIGHT 2022 Fortiortech Shenzhen
   3           * @file      UARTInit.c
   4           * @author    Fortiortech  Appliction Team
   5           * @since     Create:2021-05-14
   6           * @date      Last modify:2022-07-14
   7           * @brief     This file contains UART initial function used for Motor Control.
   8           */
   9              
  10          #include <FU68xx_2.h>
  11          #include <Myproject.h>
  12          
  13          MCUART xdata Uart;
  14          
  15          
  16          /**
  17           * @brief      Uart初始化
  18           */
  19          void UART_Init(void)
  20          {
  21   1          P0_OE |= P05;
  22   1          P0_PU |= P05;
  23   1          P0_OE &= ~P06;
  24   1          P0_PU |= P06;
  25   1          SetBit(PH_SEL, UARTEN);     //使能串口
  26   1          ClrBit(PH_SEL, UARTCH);     //ClrBit(PH_SEL, UARTCH)p0[6]as UART_RXD,p0[5]as UART_TXD;SetBit(PH_SEL, U
             -ARTCH)p3[3]as UART_RXD,p3[4]as UART_TXD;
  27   1          UT_MOD1 = 0;
  28   1          UT_MOD0 = 1;                //MODE1:8bit波特率可变UART模式
  29   1          SM2 = 0;                    //禁止Mode2和Mode3多机通讯
  30   1          REN = 1;                    //使能接收
  31   1          ES0 = 0;                    //先关中断
  32   1          PUART1 = 0;                 //中断优先级时最低
  33   1          PUART0 = 0;
  34   1          UT_BAUD = 0x9b;             //  波特率=fcpu_clk/((16/(1+UT_BAUD[BAUD_SEL]))*(UT_BAUD+1))； UT_BAUD
             -[BAUD_SEL]为UT_BAUD.15 ;default baudrate:9600-0x9b,4800-0x137;2400-0x270;1200-0x4E1
  35   1          ES0 = 1;                    //ES0 发送/接受中断使能位
  36   1          #if (0)
                  {
                      SetBit(PH_SEL, UARTEN); //p0[6]as UART_RXD; p0[5]as UART_TXD
                      UT_MOD1 = 0;
                      UT_MOD0 = 1;            //8bit波特率可变UART模式
                      SM2 = 0;                //禁止Mode2和Mode3多机通讯
                      REN = 1;                //使能接收
                      ES0 = 0;                //先关中断
                      PUART1 = 0;             //中断优先级时最低
                      PUART0 = 0;
                      UT_BAUD = 0x4E1;        //default baudrate:9600-0x9b,1200-0x4E1
                      ES0 = 1;                //发送/接受中断使能
                  }
                  #endif
  50   1      }
  51          
  52          
C51 COMPILER V9.52.0.0   UART                                                              04/01/2023 22:13:45 PAGE 2   

  53          
  54          /**
  55           * @brief      Uart发送数据
  56           */
  57          void UartTxdate(uint16 * sndBuf, int32 len)
  58          {
  59   1          uint16 i = 0;
  60   1          
  61   1          for (i = 0; i < len; i++)
  62   1          {
  63   2              UART_SendData(*sndBuf++);
  64   2          }
  65   1      }
  66          
  67          /**
  68           * @brief      Uart发送数据
  69           */
  70          void UART_SendData(unsigned char T_Data)
  71          {
  72   1          UT_DR = T_Data;
  73   1          
  74   1          while (!(TI == 1));         //等待发送完成
  75   1          
  76   1          TI = 0;                     //发送完成中断标志位清零
  77   1      }
  78          
  79          
  80          /**
  81           * @brief      处理串口接收到的数据
  82           */
  83          void UartDealResponse(void)
  84          {
  85   1      }
  86          
  87          
  88          /**
  89           * @brief      串口数据处理
  90           */
  91          void UartDealComm(void)
  92          {
  93   1          uint16 j = 0;
  94   1          uint16 checkdate = 0x00;
  95   1          
  96   1          if (Uart.ResponceFlag == 1) //10ms
  97   1          {
  98   2              //         UartDealResponse();
  99   2              Uart.T_DATA[0]     = 0xaa;
 100   2              Uart.T_DATA[1]     = (int)mcState;
 101   2              Uart.T_DATA[2]     = (uint16)(((int32)mcFocCtrl.SpeedFlt * 2400) >> 19);  // actual speed/16 ,if a
             -ctual speed=1000rpm/min,then TxBuf[2]=63
 102   2              Uart.T_DATA[3]     = (uint16)(((int32)mcFocCtrl.mcDcbusFlt * 626) >> 16); // DC bus feedback, 1 st
             -and for 2V
 103   2              Uart.T_DATA[4]     = (int)mcFaultSource;//Fault state
 104   2              Uart.T_DATA[5]     = 0x00;
 105   2              Uart.T_DATA[6]     = 0x00;
 106   2              Uart.T_DATA[7]     = 0x00;
 107   2              
 108   2              for ( j = 0; j < 7; j++ )
 109   2              {
 110   3                  checkdate += Uart.T_DATA[j];
 111   3              }
 112   2              
C51 COMPILER V9.52.0.0   UART                                                              04/01/2023 22:13:45 PAGE 3   

 113   2              Uart.T_DATA[8]     = checkdate;
 114   2              Uart.T_DATA[9]     = 0x55;
 115   2              UartTxdate(Uart.T_DATA, 10);
 116   2              Uart.ResponceFlag = 0;
 117   2          }
 118   1      }
 119          
 120          static uint8 uartRdata[10];
 121          static uint8 uartRecCnt = 0;
 122          
 123          static uint8 uartSenddata[10];
 124          static uint8 uartSendCnt = 0;
 125          
 126          
 127          /** 
 128           * @brief        Uart
 129           * @param[in]    ptBuf
 130           * @param[in]    u8Size
 131           * @return       sum
 132           */
 133          /*  -------------------------------------------------------------------------------------------------
 134              Function Name  : LrcCal
 135              Description    : Uart
 136              Date           : 2020-08-08
 137              Parameter      : ptBuf: [输入]
 138          **                                  u8Size: [输入]
 139              ------------------------------------------------------------------------------------------------- */
 140          uint8 LrcCal(uint8 * ptBuf, uint8 u8Size)
 141          {
 142   1          uint8 i, sum;
 143   1          sum = 0;
 144   1          
 145   1          for (i = 0; i < u8Size; i++)
 146   1          {
 147   2              sum += ptBuf[i];
 148   2          }
 149   1          
 150   1          return sum;
 151   1      }
 152          
 153          
 154          /**
 155           * @brief      Uart
 156           */
 157          void SendConPack(void)
 158          {
 159   1          UART_SEND * ptXy = (UART_SEND *)uartSenddata;
 160   1          ptXy->u8Start  = 0xaa;
 161   1          ptXy->u8State  = 0;
 162   1          ptXy->u16Rpm   = mcFocCtrl.SpeedFlt;
 163   1          ptXy->u16Power = mcFocCtrl.Powerlpf;
 164   1          ptXy->u8Err    = (int)mcFaultSource;
 165   1          ptXy->u8lrc    = LrcCal(uartSenddata, sizeof(UART_SEND) - 2);
 166   1          ptXy->u8End    = 0x55;
 167   1      }
 168          
 169          /**
 170           * @brief      Uart
 171           */
 172          void UartRecIsr(void)
 173          {
 174   1          UART_REC * ptXy = (UART_REC *)uartRdata;
C51 COMPILER V9.52.0.0   UART                                                              04/01/2023 22:13:45 PAGE 4   

 175   1          
 176   1          //    uint8 i;
 177   1          if (Uart.uartTimer >= 20)
 178   1          {
 179   2              uartRecCnt = 0;
 180   2          }
 181   1          
 182   1          Uart.uartTimer = 0;
 183   1          
 184   1          if (uartRecCnt < sizeof(uartRdata))
 185   1          {
 186   2              uartRdata[uartRecCnt++] = Uart.Uredata;
 187   2          }
 188   1          
 189   1          if (ptXy->u8Start == 0xaa)
 190   1          {
 191   2              if (uartRecCnt >= sizeof(UART_REC))
 192   2              {
 193   3                  if (ptXy->u8Lrc == LrcCal(uartRdata, sizeof(UART_REC) - 2))
 194   3                  {
 195   4                      Uart.uartTimerCtl = 3000;
 196   4                      Uart.power = ptXy->u8State;
 197   4                      Uart.rpmCtrl = ptXy->u16Rpm;
 198   4                      SendConPack();
 199   4                      uartSendCnt = 0;
 200   4                      GP36 ^= 1;
 201   4                      TI = 1;
 202   4                  }
 203   3              }
 204   2          }
 205   1          else
 206   1          {
 207   2              uartRecCnt = 0;
 208   2          }
 209   1      }
 210          
 211          /**
 212           * @brief      Uart数据传输
 213           */
 214          void UartSendIsr(void)
 215          {
 216   1          if (uartSendCnt < sizeof(UART_SEND))
 217   1          {
 218   2              UT_DR =  uartSenddata[uartSendCnt++];
 219   2          }
 220   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    781    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     86      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
