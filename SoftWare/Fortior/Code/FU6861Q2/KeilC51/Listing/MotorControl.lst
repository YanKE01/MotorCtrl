C51 COMPILER V9.52.0.0   MOTORCONTROL                                                      04/01/2023 22:13:42 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MOTORCONTROL
OBJECT MODULE PLACED IN .\Output\MotorControl.obj
COMPILER INVOKED BY: D:\IDE\keil\C51\BIN\C51.EXE ..\User\Source\Function\MotorControl.c LARGE OMF2 WARNINGLEVEL(0) BROWS
                    -E INCDIR(..\User\Include;..\FU68xx_Hardware_Driver\Include) DEBUG PRINT(.\Listing\MotorControl.lst) TABS(2) OBJECT(.\Out
                    -put\MotorControl.obj)

line level    source

   1          /**
   2           * @copyright (C) COPYRIGHT 2022 Fortiortech Shenzhen
   3           * @file      MotorControl.c
   4           * @author    Fortiortech  Appliction Team
   5           * @since     Create:2021-04-10
   6           * @date      Last modify:2022-07-14
   7           * @brief
   8           */
   9          
  10          /* -----Includes ----- */
  11          #include <FU68xx_2.h>
  12          #include <Myproject.h>
  13          
  14          /* -----Private variables ----- */
  15          MotStaType xdata mcState;
  16          
  17          MotStaM xdata McStaSet;
  18          uint16 TimeCnt;
  19          
  20          /**
  21           * @brief     ÁîµÊú∫ÊéßÂà∂Áä∂ÊÄÅÊú∫
  22           * @warning   ÁîµÊú∫ÁöÑÁä∂ÊÄÅÂè™ËÉΩÂú®ÁîµÊú∫Áä∂ÊÄÅÊéßÂà∂‰∏≠ÂàáÊç¢ÔºåÁ¶ÅÊ≠¢Âú®ÂÖ∂‰ªñÂú∞ÊñπÂàáÊç¢ÁîµÊú∫Áä∂ÊÄ
             -Å
  23           */
  24          void MC_Control(void)
  25          {
  26   1          switch (mcState)
  27   1          {
  28   2          case mcReady: // ÂÖ≥Èó≠ËæìÂá∫,‰∏äÁîµ‰ºöÂØπÁîµÊµÅËøõË°åÈááÈõÜÊ†°ÂáÜ,ÂΩìÈááÊ†∑Ê†°ÂáÜÁªìÊùüÊ†áÂøóÁΩÆ1‰∏îÂ
             -êØÂä®Êåá‰ª§ÁΩÆ1ÂêéÔºåÊâçË∑≥ËΩ¨Âà∞mcInit
  29   2              if (mcFaultSource != FaultNoSource)
  30   2              {
  31   3                  mcState = mcFault;
  32   3              }
  33   2              else
  34   2              {
  35   3                  Motor_Ready();
  36   3      
  37   3                  if ((mcCurOffset.OffsetFlag == 1) && (mcSpeedRamp.FlagONOFF == 1) && (mcFocCtrl.mcDcbusFlt > U
             -NDER_RECOVER_VALUE))
  38   3                  {
  39   4                      mcState = mcInit;
  40   4                      mcCurOffset.OffsetFlag = 0;
  41   4                      mcCurOffset.OffsetCount = 0; // ÂÅèÁΩÆÁîµÂéãÈááÈõÜËÆ°Êï∞
  42   4                  }
  43   3              }
  44   2      
  45   2              break;
  46   2      
  47   2          case mcInit:
  48   2              if (mcFaultSource != FaultNoSource) // ‰ºòÂÖàÊ£ÄÊü•ÊòØÂê¶ÊúâÈîôËØØÔºåËã•ÊúâÈîôËØØÂàôË∑≥ËΩ¨Ëá≥ÈîôËØ
             -ØÁä∂ÊÄÅ
  49   2              {
C51 COMPILER V9.52.0.0   MOTORCONTROL                                                      04/01/2023 22:13:42 PAGE 2   

  50   3                  mcState = mcFault;
  51   3              }
  52   2              else if (mcSpeedRamp.FlagONOFF == 0)
  53   2              {
  54   3                  mcState = mcStop;
  55   3                  mcFocCtrl.State_Count = 10;
  56   3              }
  57   2              else if (mcCurOffset.OffsetFlag == 1)
  58   2              {
  59   3                  Motor_Init();
  60   3      #if (TailWind_Mode == NoTailWind)
              #if (PosCheckEnable == 1)
                          mcState = mcPosiCheck;
                          McStaSet.SetFlag.PosiCheckSetFlag = 0;
                          mcFocCtrl.mcPosCheckAngle = 0xffff; // ËßíÂ∫¶ËµãÂàùÂÄº
              #elif (AlignEnable == 1)
                          mcFocCtrl.mcPosCheckAngle = Align_Angle;
                          mcState = mcAlign;
                          mcFocCtrl.State_Count = Align_Time;
              #else
                          mcState = mcStart;
              #endif
              #else
  73   3                  mcFocCtrl.State_Count = 100; //(ms) È°∫ÈÄÜÈ£éÂà§Êñ≠Êó∂Èó¥
  74   3                  mcFocCtrl.Brake_Count = 100; //(ms) ‰ΩéÈÄüÂàπËΩ¶Êó∂Èó¥ËÆæÁΩÆ
  75   3                  mcState = mcTailWind;
  76   3      #endif
  77   3              }
  78   2              else
  79   2              {
  80   3              }
  81   2      
  82   2              break;
  83   2      #if (TailWind_Mode != NoTailWind)
  84   2      
  85   2          case mcTailWind:
  86   2              if (mcFaultSource != FaultNoSource)
  87   2              {
  88   3                  mcState = mcFault;
  89   3              }
  90   2              else if (mcSpeedRamp.FlagONOFF == 0)
  91   2              {
  92   3                  mcState = mcStop;
  93   3                  mcFocCtrl.State_Count = 100;
  94   3              }
  95   2              else
  96   2              {
  97   3                  Motor_TailWind();
  98   3      
  99   3                  if (mcFocCtrl.WindFlag == 1)
 100   3                  {
 101   4      #if (PosCheckEnable == 1)
                              mcState = mcPosiCheck;
                              McStaSet.SetFlag.PosiCheckSetFlag = 0;
                              mcFocCtrl.mcPosCheckAngle = 0xffff; // ËßíÂ∫¶ËµãÂàùÂÄº
              #elif (AlignEnable == 1)
                              mcFocCtrl.mcPosCheckAngle = Align_Angle;
                              mcState = mcAlign;
                              mcFocCtrl.State_Count = Align_Time;
              #else
 110   4                      mcState = mcStart;
 111   4      #endif
C51 COMPILER V9.52.0.0   MOTORCONTROL                                                      04/01/2023 22:13:42 PAGE 3   

 112   4                  }
 113   3                  else if (mcFocCtrl.WindFlag == 2)
 114   3                  {
 115   4                      mcState = mcRun;
 116   4                  }
 117   3              }
 118   2      
 119   2              break;
 120   2      #endif
 121   2      #if (PosCheckEnable == 1)
              
                  case mcPosiCheck:
                      if (mcFaultSource != FaultNoSource)
                      {
                          mcState = mcFault;
                      }
                      else if (mcSpeedRamp.FlagONOFF == 0)
                      {
                          mcState = mcStop;
                          mcFocCtrl.State_Count = 10;
                      }
                      else
                      {
                          // RPD();
                      }
              
                      break;
              #endif
 140   2      #if (AlignEnable == 1)
              
                  case mcAlign: // È¢ÑÂÆö‰ΩçÊó∂Èó¥ÁªìÊùüÂêéÔºåÁõ¥Êé•ÂêØÂä®; AlignTestMode=1Áî®‰∫éÂàùÂßã‰ΩçÁΩÆÊ£ÄÊµãË∞ÉËØ
             -ïÁî®
                      if (mcFaultSource != FaultNoSource)
                      {
                          mcState = mcFault;
                      }
                      else if (mcSpeedRamp.FlagONOFF == 0)
                      {
                          mcState = mcStop;
                          mcFocCtrl.State_Count = 10;
                      }
                      else
                      {
                          Motor_Align();
              #if (AlignTestMode == 1)
                          {
                              while (1)
                                  ;
                          }
              #else
                          {
                              if (mcFocCtrl.State_Count == 0)
                              {
                                  mcState = mcStart;
                              }
                          }
              #endif
                      }
              
                      break;
              #endif
 172   2      
C51 COMPILER V9.52.0.0   MOTORCONTROL                                                      04/01/2023 22:13:42 PAGE 4   

 173   2          case mcStart: // ÈÖçÁΩÆÁîµÊú∫ÂêØÂä®ÂèÇÊï∞ÔºåËøõÂÖ•mcRunÁä∂ÊÄÅ„ÄÇ
 174   2              if (mcFaultSource != FaultNoSource)
 175   2              {
 176   3                  mcState = mcFault;
 177   3              }
 178   2              else if (mcSpeedRamp.FlagONOFF == 0)
 179   2              {
 180   3                  mcState = mcStop;
 181   3                  mcFocCtrl.State_Count = 10;
 182   3              }
 183   2              else
 184   2              {
 185   3                  FOC_Init();
 186   3                  Motor_Open();
 187   3                  mcState = mcRun;
 188   3              }
 189   2      
 190   2              break;
 191   2      
 192   2          case mcRun: // ËøêË°åÁä∂ÊÄÅÔºåËã•ËøêË°åÁä∂ÊÄÅÁöÑÁªôÂÆöÂèò‰∏∫0ÔºåËøõÂÖ•mcStopÁä∂ÊÄÅ„ÄÇ
 193   2              if (mcFaultSource != FaultNoSource)
 194   2              {
 195   3                  mcState = mcFault;
 196   3              }
 197   2              else if (mcSpeedRamp.FlagONOFF == 0)
 198   2              {
 199   3                  mcState = mcStop;
 200   3                  mcFocCtrl.State_Count = 5;
 201   3              }
 202   2              else
 203   2              {
 204   3              }
 205   2      
 206   2              break;
 207   2      
 208   2          case mcStop:
 209   2              if (mcFaultSource != FaultNoSource)
 210   2              {
 211   3                  mcState = mcFault;
 212   3              }
 213   2              else
 214   2              {
 215   3                  //            if((mcFocCtrl.SpeedFlt < _Q15( 1000 / MOTOR_SPEED_BASE))||(mcFocCtrl.State_Count
             -==0)) //
 216   3                  if ((mcFocCtrl.Powerlpf < 0.8 * Motor_Max_Power) || (mcFocCtrl.State_Count == 0)) //
 217   3                  {
 218   4      #if (StopBrakeFlag == 0)
 219   4                      {
 220   5                          mcState = mcReady;
 221   5                          MOE = 0;
 222   5                          FOC_CR1 = 0x00;
 223   5                          ClrBit(DRV_CR, FOCEN);
 224   5                      }
 225   4      #else
                              {
                                  if (mcFocCtrl.SpeedFlt < Motor_Stop_Speed)
                                  {
                                      MOE = 0;
                                      FOC_CR1 = 0x00;
                                      ClrBit(DRV_CR, FOCEN);
                                      DRV_DR = DRV_ARR + 1;
                                      DRV_CMR &= 0xFFC0;
C51 COMPILER V9.52.0.0   MOTORCONTROL                                                      04/01/2023 22:13:42 PAGE 5   

                                      DRV_CMR |= 0x015;    // ‰∏âÁõ∏‰∏ãÊ°•ËáÇÈÄöÔºåÂàπËΩ¶,Ê≥®ÊÑèÊúâÊïàÁîµÂπ≥
                                      ClrBit(DRV_CR, OCS); // OCS = 0, DRV_COMR;OCS = 1, FOC/SVPWM/SPWM
                                      MOE = 1;
                                      mcState = mcBrake;
                                      mcFocCtrl.State_Count = StopWaitTime;
                                  }
                              }
              #endif
 242   4                  }
 243   3                  else if (mcSpeedRamp.FlagONOFF == 1)
 244   3                  {
 245   4                      mcState = mcRun;
 246   4                      mcFocCtrl.CtrlMode = 0;
 247   4                      FOC_IQREF = IQ_RUN_CURRENT;
 248   4                  }
 249   3                  else
 250   3                  {
 251   4                  }
 252   3              }
 253   2      
 254   2              break;
 255   2      
 256   2          case mcBrake:
 257   2              if (mcFocCtrl.State_Count == 0)
 258   2              {
 259   3                  mcState = mcReady;
 260   3                  MOE = 0;
 261   3                  ClrBit(DRV_CR, FOCEN);
 262   3              }
 263   2      
 264   2              break;
 265   2      
 266   2          case mcFault:
 267   2              FaultProcess();
 268   2      
 269   2              if (mcFaultSource == FaultNoSource)
 270   2              {
 271   3                  mcState = mcReady;
 272   3              }
 273   2      
 274   2              _nop_();
 275   2              break;
 276   2      
 277   2          default:
 278   2              mcState = mcReady;
 279   2              break;
 280   2          }
 281   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    446    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
C51 COMPILER V9.52.0.0   MOTORCONTROL                                                      04/01/2023 22:13:42 PAGE 6   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
