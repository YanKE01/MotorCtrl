C51 COMPILER V9.52.0.0   BEMFDETECT                                                        04/01/2023 22:13:43 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE BEMFDETECT
OBJECT MODULE PLACED IN .\Output\BEMFDetect.obj
COMPILER INVOKED BY: D:\IDE\keil\C51\BIN\C51.EXE ..\User\Source\Function\BEMFDetect.c LARGE OMF2 WARNINGLEVEL(0) BROWSE 
                    -INCDIR(..\User\Include;..\FU68xx_Hardware_Driver\Include) DEBUG PRINT(.\Listing\BEMFDetect.lst) TABS(2) OBJECT(.\Output\
                    -BEMFDetect.obj)

line level    source

   1          /**************************** (C) COPYRIGHT 2017 Fortiortech shenzhen *****************************
   2          * File Name          : BEMFDetect.c
   3          * Author             : Vina Peng,Fortiortech  Appliction Team
   4          * Version            : V1.0
   5          * Date               : 10-Apr-2017
   6          * Description        : This file contains BEMF detection used for Motor Control.
   7          ***************************************************************************************************
   8          * All Rights Reserved
   9          **************************************************************************************************/
  10          
  11          
  12          /* Includes -------------------------------------------------------------------------------------*/
  13          #include <FU68xx_2.h>
  14          #include <Myproject.h>
  15          
  16          /* Private typedef ------------------------------------------------------------------------------*/
  17          /* Private define -------------------------------------------------------------------------------*/
  18          /* Private macro --------------------------------------------------------------------------------*/
  19          /* Private variables ----------------------------------------------------------------------------*/
  20          
  21          /* Private function prototypes ------------------------------------------------------------------*/
  22          /* Private functions ----------------------------------------------------------------------------*/
  23          
  24          /**
  25           * @brief     BEMFÁöÑÂàùÂßãÂåñÔºåÂåÖÊã¨ÂèòÈáèÂàùÂßãÂåñÔºå‰ΩøËÉΩÊØîËæÉÂô®
  26           */
  27          void BEMFDetectInit(void)
  28          {
  29   1          /* -----BEMFÊ£ÄÊµãÂâçÂÖ≥Èó≠mosËæìÂá∫----- */
  30   1          BEMFDetect.BEMFSpeed = 0;
  31   1          BEMFDetect.BEMFSpeedBase = 0;
  32   1          BEMFDetect.BEMFStatus = 0;
  33   1          BEMFDetect.FRStatus      = mcFRState.TargetFR;
  34   1          BEMFDetect.BEMFTimeCount = BEMF_START_DETECT_TIME;                                              //ÂàùÂ
             -ßãÂèçÁîµÂä®ÂäøÊ£ÄÊµãÊó∂Èó¥
  35   1          BEMFDetect.BEMFSpeedInitStatus = 0;
  36   1          BEMFDetect.FlagSpeedCal = 0;
  37   1          BEMFDetect.BEMFStartStatus = 0;
  38   1          /* -----‰ΩøËÉΩÂÆöÊó∂Âô®2Áî®‰∫éÊ£ÄÊµãÊó∂Èó¥----- */
  39   1          Time2_BMEF_Init();
  40   1          /* -----‰ΩøËÉΩÊØîËæÉÂô®----- */
  41   1          CMP_BMEF_Init();
  42   1      }
  43          
  44          
  45          /**
  46           * @brief      BMFÂØπÂ∫îCMPÁöÑÂàùÂßãÂåñ
  47           */
  48          void CMP_BMEF_Init(void)
  49          {
  50   1          /*  -------------------------------------------------------------------------------------------------
  51   1              CMP Input Pin Mode
  52   1              0: GPIO Mode, P1.4--CMP0_IN+, P1.6--CMP1_IN+, P2.1--CMP2_IN+
C51 COMPILER V9.52.0.0   BEMFDETECT                                                        04/01/2023 22:13:43 PAGE 2   

  53   1                        P1.5--CMP0_IN-, P1.7--CMP1_IN-, P2.2--CMP2_IN-
  54   1              1: BEMF Mode, ÊØîËæÉÂô®Ê≠£Á´ØËøûÊé•Âà∞ÂÜÖÈÉ®ÊòüÂûãËøûÊé•ÁîµÈòªU„ÄÅV„ÄÅWÁöÑBMEFÈááÊ†∑ÁÇπÔºå
  55   1                        ÊØîËæÉÂô®Ë¥üÁ´ØËøûÊé•Âà∞ÂÜÖÈÉ®ÊòüÂûãËøûÊé•ÁîµÈòªÁöÑËôöÊãü‰∏≠ÊÄßÁÇπ
  56   1                        ÊØîËæÉÂô®Ë¥üÁ´Ø‰∏éP1.5/P1.7/P2.2Êñ≠ÂºÄÔºåËøô‰∏â‰∏™GPIOÂèØÂÅöÂÖ∂‰ªñÁî®ÈÄî
  57   1              -------------------------------------------------------------------------------------------------*
             -/
  58   1          SetBit(P1_AN, P14 | P16);                                                                       // CMP
             -0„ÄÅCMP1
  59   1          SetBit(P2_AN, P21);                                                                             // CMP
             -2
  60   1          /*  -------------------------------------------------------------------------------------------------
  61   1              CMP0_MODÔºö
  62   1              00Ôºö  Êó†ÂÜÖÁΩÆËôöÊãü‰∏≠ÂøÉÁÇπÁîµÈòªÁöÑBEMFÊ®°Âºè
  63   1              01Ôºö  ÂÜÖÁΩÆËôöÊãü‰∏≠ÂøÉÁÇπÁîµÈòªÁöÑBEMFÊ®°Âºè
  64   1              10Ôºö  3Â∑ÆÂàÜÊØîËæÉÂô®Ê®°Âºè
  65   1              11Ôºö  2ÊØîËæÉÂô®Ê®°Âºè
  66   1              -------------------------------------------------------------------------------------------------*
             -/
  67   1          SetReg(CMP_CR2, CMP0MOD0 | CMP0MOD1, CMP0MOD0);
  68   1          /*  -------------------------------------------------------------------------------------------------
  69   1              ÊØîËæÉÂô®ËæìÂá∫ÈÄâÊã©ÈÖçÁΩÆÔºå‰∏éCMP0_MODÈÖçÂêà‰ΩøÁî®
  70   1              CMP0_SEL[1:0]=00ÔºåÊØîËæÉÂô®0Â∑•‰ΩúÂú®3ÊØîËæÉÂô®ËΩÆËØ¢Ê®°ÂºèÔºåÊ≠£Á´ØÂú®CMP0P„ÄÅCMP1P„ÄÅCMP2P‰πãÈó
             -¥Ëá™Âä®ËΩÆÊµÅÈÄâÊã©Ôºå
  71   1                            Ë¥üÁ´ØÂõ∫ÂÆöÊé•ÂÜÖÁΩÆBEMFÁîµÈòªÁöÑ‰∏≠ÂøÉÁÇπÔºåÂÖ∂ËæìÂá∫ÁªìÊûúÂàÜÂà´ÈÄÅËá≥CMP0_OUT„ÄÅ
             -CMP1_OUT„ÄÅCMP2_OUT
  72   1              CMP0_SEL[1:0]=01ÔºåÊØîËæÉÂô®0ÈÄâÊã©CMP0ÂØπÂ∫îÁöÑÁ´ØÂè£ÁªÑÂêàÔºåÊ≠£Á´ØÊé•CMP0PÔºåË¥üÁ´ØÊé•ÂÜÖÁΩÆBEM
             -FÁîµÈòªÁöÑ‰∏≠ÂøÉÁÇπÔºåËæìÂá∫Êé•CMP0_OUT
  73   1              CMP0_SEL[1:0]=10ÔºåÊØîËæÉÂô®0ÈÄâÊã©CMP1ÂØπÂ∫îÁöÑÁ´ØÂè£ÁªÑÂêàÔºåÊ≠£Á´ØÊé•CMP1PÔºåË¥üÁ´ØÊé•ÂÜÖÁΩÆBEM
             -FÁîµÈòªÁöÑ‰∏≠ÂøÉÁÇπÔºåËæìÂá∫Êé•CMP1_OUT
  74   1              CMP0_SEL[1:0]=11ÔºåÊØîËæÉÂô®0ÈÄâÊã©CMP2ÂØπÂ∫îÁöÑÁ´ØÂè£ÁªÑÂêàÔºåÊ≠£Á´ØÊé•CMP2PÔºåË¥üÁ´ØÊé•ÂÜÖÁΩÆBEM
             -FÁîµÈòªÁöÑ‰∏≠ÂøÉÁÇπÔºåËæìÂá∫Êé•CMP2_OUT
  75   1          
  76   1              -----------------------------------------------------------------------------*/
  77   1          SetReg(CMP_CR2, CMP0SEL0 | CMP0SEL1, 0x00);
  78   1          /*  -------------------------------------------------------------------------------------------------
  79   1              ÊØîËæÉÂô®ËøüÊªûÁîµÂéãÈÄâÊã©
  80   1              000: Êó†ËøüÊªû   001: ¬±2.5mV   010: -5mV   011: +5mV
  81   1              100: +-5mV   101: -10mV   110: +10mV   111: +-10mV
  82   1              -------------------------------------------------------------------------------------------------*
             -/
  83   1          SetReg(CMP_CR1, CMP0HYS0 | CMP0HYS1 | CMP0HYS2, CMP0HYS2  );
  84   1          /*  -------------------------------------------------------------------------------------------------
  85   1              CMP0ÁöÑËΩÆËØ¢Êó∂Èó¥ËÆæÁΩÆ
  86   1              -------------------------------------------------------------------------------------------------*
             -/
  87   1          SetReg(CMP_CR2, CMP0CSEL1 | CMP0CSEL0, 0x00);
  88   1          /*  -------------------------------------------------------------------------------------------------
  89   1              ÊØîËæÉÂô®‰∏≠Êñ≠Ê®°ÂºèÈÖçÁΩÆ
  90   1              00: ‰∏ç‰∫ßÁîü‰∏≠Êñ≠  01: ‰∏äÂçáÊ≤ø‰∫ßÁîü‰∏≠Êñ≠  10: ‰∏ãÈôçÊ≤ø‰∫ßÁîü‰∏≠Êñ≠  11: ‰∏äÂçá/‰∏ãÈôçÊ≤ø‰∫ß
             -Áîü‰∏≠Êñ≠
  91   1              -------------------------------------------------------------------------------------------------*
             -/
  92   1          SetReg(CMP_CR0, CMP2IM0 | CMP2IM1, CMP2IM0 | CMP2IM1);
  93   1          SetReg(CMP_CR0, CMP1IM0 | CMP1IM1, CMP1IM0 | CMP1IM1);
  94   1          SetReg(CMP_CR0, CMP0IM0 | CMP0IM1, CMP0IM0 | CMP0IM1);
  95   1          SetBit(CMP_CR2, CMP0EN);                                                                        //ÂºÄ‰
             -∏â‰∏™ÊØîËæÉÂô®
  96   1          //  SetBit(CMP_CR2, CMP0EN);
  97   1          //  SetBit(CMP_CR2, CMP0EN);
  98   1      }
  99          
 100          
C51 COMPILER V9.52.0.0   BEMFDETECT                                                        04/01/2023 22:13:43 PAGE 3   

 101          /**
 102           * @brief      BMFÂØπÂ∫îTime2ÁöÑÂàùÂßãÂåñ
 103           */
 104          void Time2_BMEF_Init(void)
 105          {
 106   1          /*  -------------------------------------------------------------------------------------------------
 107   1              ÂÖàÂÅúÊ≠¢ËÆ°Êï∞ÔºåÈÖçÁΩÆÂÆåÂØÑÂ≠òÂô®ÂêéÔºåÊúÄÂêéÂêØÂä®ËÆ°Êï∞
 108   1              -------------------------------------------------------------------------------------------------*
             -/
 109   1          ClrBit(TIM2_CR1, T2EN);                                                                         // 0Ôº
             -åÂÅúÊ≠¢ËÆ°Êï∞Ôºõ1,‰ΩøËÉΩËÆ°Êï∞
 110   1          /*  -------------------------------------------------------------------------------------------------
 111   1              Êó∂ÈíüÂàÜÈ¢ëËÆæÁΩÆ(T2PSC)
 112   1              000:cpuclk(24MHz)         001:cpuclk/2^1(12MHz)   010:cpuclk/2^2(6MHz)    011:cpuclk/2^3(3MHz)
 113   1              100:cpuclk/2^4(1.5MHz)    101:cpuclk/2^5(750KHz)  110:cpuclk/2^6(375KHz)  111:cpuclk/2^7(187.5KHz)
 114   1              -------------------------------------------------------------------------------------------------*
             -/
 115   1          SetReg(TIM2_CR0, T2PSC0 | T2PSC1 | T2PSC2, T2PSC2);
 116   1          /*  -------------------------------------------------------------------------------------------------
 117   1              /Ê®°ÂºèÈÄâÊã©
 118   1              T2MODE1ÔºåT2MODE0
 119   1              00--ËæìÂÖ•TimerÊ®°ÂºèÔºõ01--ËæìÂá∫Ê®°Âºè
 120   1              10--ËæìÂÖ•CountÊ®°ÂºèÔºõ11--QEPÊàñËÄÖRSDÊ®°Âºè
 121   1              -------------------------------------------------------------------------------------------------*
             -/
 122   1          SetReg(TIM2_CR0, T2MOD0 | T2MOD1, T2MOD0);
 123   1          /*  -------------------------------------------------------------------------------------------------
 124   1              Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó‰Ωç
 125   1              Á¶ÅÊ≠¢PWMÂë®ÊúüÊ£ÄÊµã‰∏≠Êñ≠‰ΩøËÉΩ
 126   1              -------------------------------------------------------------------------------------------------*
             -/
 127   1          ClrBit(TIM2_CR0, T2CES);                                                                        // Ê∏Ö
             -Èõ∂ËÑâÂÜ≤ËÆ°Êï∞Âô®‰∏ç‰ΩøËÉΩ
 128   1          ClrBit(TIM2_CR1, T2IR | T2IF | T2IP);                                                           // Ê∏Ö
             -Èõ∂‰∏≠Êñ≠Ê†áÂøó‰Ωç
 129   1          /*  -------------------------------------------------------------------------------------------------
 130   1              ÈÖçÁΩÆÂë®ÊúüÂÄº„ÄÅÊØîËæÉÂÄº„ÄÅËÆ°Êï∞ÂÄº
 131   1              Á¶ÅÊ≠¢PWMÂë®ÊúüÊ£ÄÊµã‰∏≠Êñ≠‰ΩøËÉΩ
 132   1              ‰ΩøËÉΩËÆ°Êï∞Âô®‰∏äÊ∫¢‰∏≠Êñ≠‰ΩøËÉΩ
 133   1              -------------------------------------------------------------------------------------------------*
             -/
 134   1          TIM2__ARR = 60000;                                                                              // TIM
             -2 Period = 0.32s
 135   1          TIM2__DR = TIM2__ARR;
 136   1          TIM2__CNTR = 0;
 137   1          /*-----------ÂêØÂä®ËÆ°Êï∞------------------------------------------------*/
 138   1          SetBit(TIM2_CR1, T2EN);                                                                         //ÂêØÂ
             -ä®ËÆ°Êï∞
 139   1      }
 140          
 141          
 142          /**
 143           * @brief      ËØªÂèçÁîµÂä®ÂäøÁä∂ÊÄÅ
 144           */
 145          uint8   GetBEMFStatus(void)
 146          {
 147   1          uint8 BEMFStatus = 0;
 148   1          
 149   1          if (ReadBit(CMP_SR, CMP2OUT))
 150   1          {
 151   2              BEMFStatus += 4;
 152   2          }
C51 COMPILER V9.52.0.0   BEMFDETECT                                                        04/01/2023 22:13:43 PAGE 4   

 153   1          
 154   1          if (ReadBit(CMP_SR, CMP1OUT))
 155   1          {
 156   2              BEMFStatus += 2;
 157   2          }
 158   1          
 159   1          if (ReadBit(CMP_SR, CMP0OUT))
 160   1          {
 161   2              BEMFStatus += 1;
 162   2          }
 163   1          
 164   1          return BEMFStatus;
 165   1      }
 166          
 167          
 168          /**
 169           * @brief        ÁîµÊú∫ËΩ¨ÂêëÊ£ÄÊµã
 170           * @param[in]    HallStatus
 171           * @return       ÁîµÊú∫ÊñπÂêë
 172           */
 173          uint8 CWCCWDetect(uint8 HallStatus)
 174          {
 175   1          static uint8 MC_FR = 0;
 176   1          static uint8 MC_HallStatus = 0;
 177   1          
 178   1          /* -----Á¨¨‰∏ÄÊ¨°ËøõÂÖ•‰∏≠Êñ≠----- */
 179   1          if (MC_HallStatus == 0) //
 180   1          {
 181   2              MC_HallStatus = HallStatus;
 182   2              MC_FR = CW;
 183   2              return MC_FR;
 184   2          }
 185   1          
 186   1          if (MC_HallStatus != HallStatus)
 187   1          {
 188   2              switch (MC_HallStatus)
 189   2              {
 190   3                  case 1:
 191   3                      if (HallStatus == 5)
 192   3                      {
 193   4                          MC_FR = CCW;
 194   4                      }
 195   3                      
 196   3                      if (HallStatus == 3)
 197   3                      {
 198   4                          MC_FR = CW;
 199   4                      }
 200   3                      
 201   3                      break;
 202   3                      
 203   3                  case 2:
 204   3                      if (HallStatus == 3)
 205   3                      {
 206   4                          MC_FR = CCW;
 207   4                      }
 208   3                      
 209   3                      if (HallStatus == 6)
 210   3                      {
 211   4                          MC_FR = CW;
 212   4                      }
 213   3                      
 214   3                      break;
C51 COMPILER V9.52.0.0   BEMFDETECT                                                        04/01/2023 22:13:43 PAGE 5   

 215   3                      
 216   3                  case 3:
 217   3                      if (HallStatus == 1)
 218   3                      {
 219   4                          MC_FR = CCW;
 220   4                      }
 221   3                      
 222   3                      if (HallStatus == 2)
 223   3                      {
 224   4                          MC_FR = CW;
 225   4                      }
 226   3                      
 227   3                      break;
 228   3                      
 229   3                  case 4:
 230   3                      if (HallStatus == 6)
 231   3                      {
 232   4                          MC_FR = CCW;
 233   4                      }
 234   3                      
 235   3                      if (HallStatus == 5)
 236   3                      {
 237   4                          MC_FR = CW;
 238   4                      }
 239   3                      
 240   3                      break;
 241   3                      
 242   3                  case 5:
 243   3                      if (HallStatus == 4)
 244   3                      {
 245   4                          MC_FR = CCW;
 246   4                      }
 247   3                      
 248   3                      if (HallStatus == 1)
 249   3                      {
 250   4                          MC_FR = CW;
 251   4                      }
 252   3                      
 253   3                      break;
 254   3                      
 255   3                  case 6:
 256   3                      if (HallStatus == 2)
 257   3                      {
 258   4                          MC_FR = CCW;
 259   4                      }
 260   3                      
 261   3                      if (HallStatus == 4)
 262   3                      {
 263   4                          MC_FR = CW;
 264   4                      }
 265   3                      
 266   3                      break;
 267   3                      
 268   3                  default:
 269   3                      break;
 270   3              }
 271   2              
 272   2              MC_HallStatus = HallStatus;
 273   2          }
 274   1          
 275   1          return MC_FR;
 276   1      }
C51 COMPILER V9.52.0.0   BEMFDETECT                                                        04/01/2023 22:13:43 PAGE 6   

 277          
 278          
 279          /**
 280           * @brief    ÂêØÂä®Êó∂ÁîµÊú∫ÈÄüÂ∫¶Ê£ÄÊµã
 281           */
 282          void BEMFSpeedDetect(void)
 283          {
 284   1          if (BEMFDetect.BEMFSpeedInitStatus == 0)
 285   1          {
 286   2              BEMFDetect.BEMFSpeedInitStatus = 1;
 287   2              BEMFDetect.PeriodTime = 0;
 288   2              BEMFDetect.MC_StepTime[0] = 0;
 289   2              BEMFDetect.MC_StepTime[1] = 0;
 290   2              BEMFDetect.MC_StepTime[2] = 0;
 291   2              BEMFDetect.MC_StepTime[3] = 0;
 292   2              BEMFDetect.MC_StepTime[4] = 0;
 293   2              BEMFDetect.MC_StepTime[5] = 0;
 294   2              BEMFDetect.BEMFStep = 0;
 295   2              BEMFDetect.StepTime = 0;
 296   2              BEMFDetect.FirstCycle = 0;
 297   2          }
 298   1          else
 299   1          {
 300   2              BEMFDetect.StepTime = TIM2__CNTR;
 301   2              TIM2__CNTR = 0;
 302   2              BEMFDetect.MC_StepTime[BEMFDetect.BEMFStep] = BEMFDetect.StepTime;
 303   2              BEMFDetect.PeriodTime = (BEMFDetect.MC_StepTime[0] + BEMFDetect.MC_StepTime[1] + BEMFDetect.MC_Ste
             -pTime[2] +
 304   2                      BEMFDetect.MC_StepTime[3] + BEMFDetect.MC_StepTime[4] + BEMFDetect.MC_StepTime[5]) >> 3;
 305   2              BEMFDetect.BEMFStep++;
 306   2              
 307   2              /* -----360Â∫¶ÔºåÁ¨¨‰∏ÄÂúàÊòØ360ËÆ°ÁÆó‰∏ÄÊ¨°ÈÄüÂ∫¶ÔºåÁ¨¨‰∫åÂúàÊòØ60Â∫¶ËÆ°ÁÆó‰∏ÄÊ¨°ÈÄüÂ∫¶----- */
 308   2              if (BEMFDetect.FirstCycle) //
 309   2              {
 310   3                  BEMFDetect.FlagSpeedCal = 1;
 311   3                  BEMFDetect.BEMFSpeedBase = TempBEMFSpeedBase;
 312   3              }
 313   2              else                                                                                        //60Â∫
             -¶
 314   2              {
 315   3                  BEMFDetect.FlagSpeedCal = 1;
 316   3                  BEMFDetect.BEMFSpeedBase = TempBEMFSpeedBase1;
 317   3                  BEMFDetect.PeriodTime = BEMFDetect.StepTime;
 318   3              }
 319   2              
 320   2              if (BEMFDetect.BEMFStep == 6)
 321   2              {
 322   3                  BEMFDetect.FirstCycle = 1;
 323   3                  BEMFDetect.BEMFStep = 0;
 324   3              }
 325   2          }
 326   1      }
 327          
 328          
 329          /**
 330           * @brief      ÂêØÂä®ÂâçÈÄüÂ∫¶ËÆ°ÁÆó
 331           */
 332          void BEMFSpeedCal(void)
 333          {
 334   1          /* -----Ê≠§Â§ÑÊ≥®ÊÑèXDATAÂíåÈô§Êï∞Âè™ËÉΩÊòØ16‰ΩçÁöÑÈóÆÈ¢ò----- */
 335   1          if (BEMFDetect.FlagSpeedCal) //
 336   1          {
C51 COMPILER V9.52.0.0   BEMFDETECT                                                        04/01/2023 22:13:43 PAGE 7   

 337   2              /* -----ÂæóÂà∞ÁöÑÊòØQÊ†ºÂºèÁöÑÈÄüÂ∫¶,Ê≠§Â§ÑÈô§Ê≥ïÂô®‰∏éËøáË∞ÉÂÄº‰∏çÂÜ≤Á™Å----- */
 338   2              BEMFDetect.BEMFSpeed  = MDU_DIV_XDATA_U32(&BEMFDetect.BEMFSpeedBase, &BEMFDetect.PeriodTime);//
 339   2              BEMFDetect.FlagSpeedCal = 0;
 340   2          }
 341   1      }
 342          
 343          
 344          /**
 345           * @brief      BEMFÊ£ÄÊµãÔºåÂà§Êñ≠ÊñπÂêëÔºåÈÄüÂ∫¶Ôºå‰ª•ÂèäÈ°∫È£éÂàáÈó≠ÁéØ
 346           */
 347          void BEMFDetectFunc(void)
 348          {
 349   1          if (ReadBit(CMP_SR, CMP0IF) || ReadBit(CMP_SR, CMP1IF) || ReadBit(CMP_SR, CMP2IF))              //ÂΩìÊ
             -£ÄÊµãÂà∞ÊØîËæÉÂô®‰∏≠Êñ≠Êó∂
 350   1          {
 351   2              /* -----Ê£ÄÊµãÂΩìÂâçBEMFÁä∂ÊÄÅ----- */
 352   2              BEMFDetect.BEMFStatus = GetBEMFStatus();
 353   2              /* -----Ê†πÊçÆBEMFÁä∂ÊÄÅÂà§Êñ≠FRÁä∂ÊÄÅ----- */
 354   2              BEMFDetect.FRStatus = CWCCWDetect(BEMFDetect.BEMFStatus);
 355   2              /* -----ÈÄüÂ∫¶Ê£ÄÊµã----- */
 356   2              BEMFSpeedDetect();
 357   2              /* -----ÈÄüÂ∫¶ËÆ°ÁÆó----- */
 358   2              BEMFSpeedCal();
 359   2              
 360   2              /* -----Âº∫Âà∂ÂêØÂä®Ê†áÂøó‰ΩøËÉΩÊó∂----- */
 361   2              if (BEMFDetect.BEMFStartStatus)
 362   2              {
 363   3                  /* -----CWÊó∂UÁõ∏BEMF‰∏äÂçáÊ≤øÂêØÂä®ÔºåCCWÊó∂VÁõ∏BEMF‰∏äÂçáÊ≤øÂêØÂä®----- */
 364   3                  if (((mcFRState.TargetFR == CW) && (BEMFDetect.BEMFStatus == 5)) || ((mcFRState.TargetFR == CC
             -W) && (BEMFDetect.BEMFStatus == 3)))
 365   3                  {
 366   4                      /* -----ÊâßË°åÁõ¥Êé•Èó≠ÁéØÂêØÂä®Á®ãÂ∫è----- */
 367   4                      BEMFFOCCloseLoopStart();
 368   4                      ClrBit(CMP_CR0, CMP2IM1 | CMP2IM0 | CMP1IM1 | CMP1IM0 | CMP0IM1 | CMP0IM0);
 369   4                      ClrBit(CMP_CR2, CMP0EN);
 370   4                      BEMFDetect.BEMFStartStatus = 0;
 371   4                  }
 372   3              }
 373   2              
 374   2              ClrBit(CMP_SR, CMP0IF | CMP1IF | CMP2IF);
 375   2          }
 376   1      }
 377          
 378          
 379          /**
 380           * @brief      BEMFÈ°∫ÈÄÜÈ£éÂ§ÑÁêÜ
 381           */
 382          void BEMFDealwith(void)
 383          {
 384   1          if (BEMFDetect.BEMFTimeCount < (BEMF_START_DETECT_TIME - BEMF_START_DELAY_TIME))
 385   1          {
 386   2              if (BEMFDetect.FRStatus == mcFRState.TargetFR)
 387   2              {
 388   3                  /* -----Ë∂ÖËøáËÆæÂÆöËΩ¨ÈÄüÊó∂Áõ¥Êé•ÂêØÂä®----- */
 389   3                  if ((BEMFDetect.BEMFSpeed > BEMFMotorStartSpeed) && (BEMFDetect.BEMFSpeed < BEMFMotorStartSpee
             -dHigh))
 390   3                  {
 391   4                      BEMFDetect.BEMFStartStatus = 1;
 392   4                  }
 393   3              }
 394   2              
 395   2              if ((BEMFDetect.BEMFTimeCount == 0) || (BEMFDetect.BEMFSpeed < BEMFMotorStartSpeed)) //ÈùôÊ≠¢Êàñ‰Ω
C51 COMPILER V9.52.0.0   BEMFDETECT                                                        04/01/2023 22:13:43 PAGE 8   

             -éÈÄü
 396   2              {
 397   3                  ClrBit(CMP_CR0, CMP2IM1 | CMP2IM0 | CMP1IM1 | CMP1IM0 | CMP0IM1 | CMP0IM0);
 398   3                  ClrBit(CMP_CR2, CMP0EN);
 399   3                  
 400   3                  //          mcFocCtrl.Brake_Count = 100;//‰ΩéÈÄüÂàπËΩ¶Êó∂Èó¥ËÆæÁΩÆ Âçï‰ΩçÔºö10ms
 401   3                  //          MOE = 0;
 402   3                  //            if (mcFocCtrl.Brake_Flag == 0)
 403   3                  //            {
 404   3                  //                /* -----‰ΩéÈÄü‰∏çÂÅöÂàπËΩ¶Â§ÑÁêÜ  È¢ÑÂÆö‰ΩçÂ§ÑÁêÜ----- */
 405   3                  //                FOC_CR1 = 0x00;
 406   3                  //                ClrBit(DRV_CR, FOCEN);
 407   3                  //                DRV_DR  = DRV_ARR + 1;
 408   3                  //                DRV_CMR &= 0xFFC0;
 409   3                  //                DRV_CMR |= 0x015;                                                           
             -            // ‰∏âÁõ∏‰∏ãÊ°•ËáÇÈÄöÔºåÂàπËΩ¶
 410   3                  //                ClrBit(DRV_CR, OCS);                                                        
             -            // OCS = 0, DRV_COMR;OCS = 1, FOC/SVPWM/SPWM
 411   3                  //                MOE = 1;
 412   3                  //                mcFocCtrl.Brake_Flag = 1;
 413   3                  //            }
 414   3                  
 415   3                  if (mcFocCtrl.Brake_Count == 0)                                                             //
             -ÂàπËΩ¶Êó∂Èó¥ÁªìÊùü
 416   3                  {
 417   4                      mcFocCtrl.WindFlag = 1;
 418   4                  }
 419   3              }
 420   2          }
 421   1      }
 422          
 423          
 424          /**
 425           * @brief      È°∫È£éÂêØÂä®
 426           */
 427          void BEMFFOCCloseLoopStart(void)
 428          {
 429   1          /* -----FOCÂàùÂßãÂåñ----- */
 430   1          FOC_Init();
 431   1          //    FOC__THECOMP  = _Q15(-10.0/180.0);
 432   1          //    FOC__UD = _Q15(0.0);
 433   1          //    FOC__UQ = _Q15(0.3);
 434   1          /* -----ÂêØÂä®ÁîµÊµÅ„ÄÅKP„ÄÅKI----- */
 435   1          //  FOC_IDREF = ID_Start_CURRENT;                                                               // DËΩ
             -¥ÂêØÂä®ÁîµÊµÅ
 436   1          //  mcFocCtrl.mcIqref= IQ_Start_CURRENT;                                                        // QËΩ
             -¥ÂêØÂä®ÁîµÊµÅ
 437   1          //  FOC_IQREF = mcFocCtrl.mcIqref;                                                              // QËΩ
             -¥ÂêØÂä®ÁîµÊµÅ
 438   1          //  FOC_DQKP = DQKP;
 439   1          //  FOC_DQKI = DQKI;
 440   1          FOC__THETA =  RSDDetect.RSDTheta;//
 441   1          #if ((EstimateAlgorithm == SMO  || EstimateAlgorithm == AO))
 442   1          {
 443   2              FOC__ETHETA = FOC__THETA - 4836; //30¬∞
 444   2          }
 445   1          #elif (EstimateAlgorithm == PLL)
                  {
                      FOC__ETHETA = FOC__THETA;//30¬∞
                  }
                  #endif
 450   1          FOC__EOME = BEMFDetect.BEMFSpeed;
C51 COMPILER V9.52.0.0   BEMFDETECT                                                        04/01/2023 22:13:43 PAGE 9   

 451   1          FOC_EFREQACC    = Motor_Omega_Ramp_ACC;
 452   1          FOC_EFREQMIN    = Motor_Omega_Ramp_Min;
 453   1          FOC_EFREQHOLD = Motor_Omega_Ramp_End;
 454   1          SetBit(FOC_CR1, EFAE);                                                                          // ‰º∞
             -ÁÆóÂô®Âº∫Âà∂ËæìÂá∫
 455   1          ClrBit(FOC_CR1, RFAE);                                                                          // Á¶Å
             -Ê≠¢Âº∫Êãâ
 456   1          SetBit(FOC_CR1, ANGM);                                                                          // ‰º∞
             -ÁÆóÊ®°Âºè
 457   1          //    FOC__UQ=(QOUTMAX>>1);
 458   1          #if (EstimateAlgorithm == SMO  || EstimateAlgorithm == AO)
 459   1          {
 460   2              PI2_KP = _Q12(7.0);
 461   2              PI2_KI = _Q15(0.1);
 462   2              PI3_KP = PI2_KP;
 463   2              PI3_KI = PI2_KI;
 464   2              FOC_DQKP = _Q12(5.0);
 465   2              FOC_DQKI = _Q15(0.99) ;
 466   2              FOC_EKP                 = OBSW_KP_GAIN_RUN4;
 467   2              FOC_EKI                 = OBSW_KI_GAIN_RUN4;
 468   2              mcFocCtrl.mcIqref       = I_Value(10.0);
 469   2              mcFocCtrl.State_Count   = 10;
 470   2              FOC_OMEKLPF                     = SPEED_KLPF;
 471   2              mcFocCtrl.WindFlag = 2;            //È°∫È£éÊ†áÂøó
 472   2              mcFocCtrl.CtrlMode              = 0;
 473   2              /* -----‰ΩøËÉΩËæìÂá∫----- */
 474   2              DRV_CMR |= 0x3F;                                                                            // U„Ä
             -ÅV„ÄÅWÁõ∏ËæìÂá∫
 475   2              MOE = 1;
 476   2              EA = 1;
 477   2              FOC_IQREF = mcFocCtrl.mcIqref;
 478   2          }
 479   1          #elif (EstimateAlgorithm == PLL)
                  {
                      FOC_EKP                     = OBSW_KP_GAIN_RUN4;
                      FOC_EKI                     = OBSW_KI_GAIN_RUN4;
                      mcFocCtrl.mcIqref           = IQ_RUN_CURRENT;
                  }
                  #endif                                                                                          //end 
             -   EstimateAlgorithm
 486   1      }
 487          
 488          
 489          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1084    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
