C51 COMPILER V9.52.0.0   RSDDETECT                                                         04/01/2023 22:13:43 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE RSDDETECT
OBJECT MODULE PLACED IN .\Output\RSDDetect.obj
COMPILER INVOKED BY: D:\IDE\keil\C51\BIN\C51.EXE ..\User\Source\Function\RSDDetect.c LARGE OMF2 WARNINGLEVEL(0) BROWSE I
                    -NCDIR(..\User\Include;..\FU68xx_Hardware_Driver\Include) DEBUG PRINT(.\Listing\RSDDetect.lst) TABS(2) OBJECT(.\Output\RS
                    -DDetect.obj)

line level    source

   1          /**************************** (C) COPYRIGHT 2017 Fortiortech shenzhen *****************************
   2          * File Name          : RSDDetect.c
   3          * Author             : Vina Peng,Fortiortech  Appliction Team
   4          * Version            : V1.0
   5          * Date               : 10-Apr-2017
   6          * Description        : This file contains init speed detection used for Motor Control.
   7          ***************************************************************************************************
   8          * All Rights Reserved
   9          **************************************************************************************************/
  10          
  11          
  12          /* Includes -------------------------------------------------------------------------------------*/
  13          #include <FU68xx_2.h>
  14          #include <Myproject.h>
  15          
  16          /* Private typedef ------------------------------------------------------------------------------*/
  17          /* Private define -------------------------------------------------------------------------------*/
  18          /* Private macro --------------------------------------------------------------------------------*/
  19          /* Private variables ----------------------------------------------------------------------------*/
  20          /* Private function prototypes ------------------------------------------------------------------*/
  21          /* Private functions ----------------------------------------------------------------------------*/
  22          
  23          
  24          /**
  25           * @brief      RSD初始化
  26           */
  27          void RSDDetectInit(void)
  28          {
  29   1          MOE = 0;
  30   1          RSDDetect.RSDStepTime[0] = 0;
  31   1          RSDDetect.RSDStepTime[1] = 0;
  32   1          RSDDetect.RSDStepTime[2] = 0;
  33   1          RSDDetect.RSDStepTime[3] = 0;
  34   1          RSDDetect.RSDTimes   = 0;
  35   1          RSDDetect.RSDPeriod  = 0;
  36   1          RSDDetect.RSDCount   = 0;
  37   1          RSDDetect.RSDState   = Static;
  38   1          RSDDetect.RSDSpeed   = 0;
  39   1          RSDDetect.RSDDIR     = 0;
  40   1          RSDDetect.RSDFlag    = 0;
  41   1          RSDDetect.RSDStep    = 0;
  42   1          RSDDetect.RSDBRFlag  = 0;
  43   1          ClrBit(DRV_CR, FOCEN);                                                                          // 关
             -闭FOC
  44   1          CMP_RSD_Init();
  45   1          Time2_RSD_Init();                                                                               // RSD
             -用的是Time2
  46   1      }
  47          
  48          
  49          /**
  50           * @brief      RSD对CMP的初始化
  51           */
C51 COMPILER V9.52.0.0   RSDDETECT                                                         04/01/2023 22:13:43 PAGE 2   

  52          void CMP_RSD_Init(void)
  53          {
  54   1          /*  -------------------------------------------------------------------------------------------------
  55   1              CMP Input Pin Mode
  56   1              P1.4--CMP0_IN+, P1.6--CMP1_IN+, P2.1--CMP2_IN+
  57   1              P1.5--CMP0_IN-, P1.7--CMP1_IN-, P2.2--CMP2_IN-
  58   1              P1.3--CMP1P2
  59   1              -------------------------------------------------------------------------------------------------*
             -/
  60   1          SetBit(P1_AN, P14 | P15 | HBMOD);
  61   1          ClrBit(P1_OE, P13);
  62   1          /*  -------------------------------------------------------------------------------------------------
  63   1              CMP0_MOD：
  64   1              00：   无内置虚拟中心点电阻的BEMF模式
  65   1              01：  内置虚拟中心点电阻的BEMF模式
  66   1              10：  3差分比较器模式
  67   1              11：  2比较器模式RSD
  68   1              -------------------------------------------------------------------------------------------------*
             -/
  69   1          SetReg(CMP_CR2, CMP0MOD0 | CMP0MOD1, CMP0MOD0 | CMP0MOD1);
  70   1          /*  -------------------------------------------------------------------------------------------------
  71   1              比较器输出选择配置，与CMP0_MOD配合使用
  72   1              CMP0_SEL[1:0]=00，比较器0工作在2比较器轮询模式，正端在CMP0P、CMP1P2之间自动
             -轮流选择，负端固定接CMP0M，
  73   1                                          其输出结果分别送至CMP0_OUT、CMP1_OUT
  74   1              CMP0_SEL[1:0]=01，比较器0选择CMP0对应的端口组合，即正端接CMP0P，负端接CMP0M
             -输出接CMP0_OUT
  75   1              CMP0_SEL[1:0]=10，比较器0选择CMP1对应的端口组合，即正端接CMP1P2，负端接CMP0M
             -，输出接CMP1_OUT
  76   1              -----------------------------------------------------------------------------*/
  77   1          SetReg(CMP_CR2, CMP0SEL0 | CMP0SEL1, 0x00);
  78   1          /*  -------------------------------------------------------------------------------------------------
  79   1              比较器迟滞电压选择
  80   1              000: 无迟滞   001: ±2.5mV   010: -5mV   011: +5mV
  81   1              100: +-5mV   101: -10mV   110: +10mV   111: +-10mV
  82   1              -------------------------------------------------------------------------------------------------*
             -/
  83   1          SetReg(CMP_CR1, CMP0HYS0 | CMP0HYS1 | CMP0HYS2, CMP0HYS0 | CMP0HYS1 | CMP0HYS2 );
  84   1          /*  -------------------------------------------------------------------------------------------------
  85   1              CMP0的轮询时间设置
  86   1              -------------------------------------------------------------------------------------------------*
             -/
  87   1          SetReg(CMP_CR2, CMP0CSEL0 | CMP0CSEL1, 0x00);
  88   1          EA = 0;
  89   1          /* ------------------------------------------------------
  90   1              使能比较器CMP0,CMP1,CMP2和ADC在pwm on/off采样功能
  91   1          
  92   1              00：在on和off均采样，没有延迟采样开启
  93   1              01：只在off采样，根据CMP_SAMR延迟采样开启
  94   1              10：只在on采样，根据CMP_SAMR延迟采样开启
  95   1              11：在on和off均采样，根据CMP_SAMR延迟采样开启
  96   1              --------------------------------------------------------- */
  97   1          SetReg(CMP_CR3, SAMSEL0 | SAMSEL1, 0x00);
  98   1          /* -----采样延迟设置----- */
  99   1          CMP_SAMR = 0x10;
 100   1          SetBit(CMP_CR2, CMP0EN);//使能比较器
 101   1      }
 102          
 103          
 104          /**
 105           * @brief      RSD对应Time2的初始化
 106           */
C51 COMPILER V9.52.0.0   RSDDETECT                                                         04/01/2023 22:13:43 PAGE 3   

 107          void Time2_RSD_Init(void)
 108          {
 109   1          /*  -------------------------------------------------------------------------------------------------
 110   1              先停止计数，配置完寄存器后，最后启动计数
 111   1              -------------------------------------------------------------------------------------------------*
             -/
 112   1          ClrBit(TIM2_CR1, T2EN);                                                                         // 0
             -停止计数；1,使能计数
 113   1          /*  -------------------------------------------------------------------------------------------------
 114   1              时钟分频设置(T2PSC)
 115   1              000:cpuclk(24MHz)           001:cpuclk/2^1(12MHz)   010:cpuclk/2^2(6MHz)    011:cpuclk/2^3(3MHz)
 116   1              100:cpuclk/2^4(1.5MHz)      101:cpuclk/2^5(750KHz)  110:cpuclk/2^6(375KHz)  111:cpuclk/2^7(187.5KH
             -z)
 117   1              -------------------------------------------------------------------------------------------------*
             -/
 118   1          SetReg(TIM2_CR0, T2PSC0 | T2PSC1 | T2PSC2, T2PSC2);
 119   1          /*  -------------------------------------------------------------------------------------------------
 120   1              /模式选择
 121   1              T2MODE1，T2MODE0
 122   1              00--输入Timer模式；01--输出模式
 123   1              10--输入Count模式；11--QEP或者RSD模式
 124   1              -------------------------------------------------------------------------------------------------*
             -/
 125   1          SetReg(TIM2_CR0, T2MOD0 | T2MOD1, T2MOD0 | T2MOD1);
 126   1          SetBit(TIM2_CR1, T2FE);                                                                         // 滤
             -波使能
 127   1          /*  -------------------------------------------------------------------------------------------------
 128   1              1、清除中断标志位
 129   1              2、禁止PWM周期检测中断使能
 130   1              3、使能计数器上溢中断使能
 131   1              -------------------------------------------------------------------------------------------------*
             -/
 132   1          ClrBit(TIM2_CR1, T2IR | T2IF | T2IP);                                                           // 清
             -除中断标志位
 133   1          ClrBit(TIM2_CR0, T2CES | T2IRE);                                                                // 清
             -零脉冲计数器不使能
 134   1          SetBit(TIM2_CR1, T2IPE | T2IFE);                                                                // 输
             -入有效边沿变化中断使能和基本计数器上溢使能
 135   1          /*  -------------------------------------------------------------------------------------------------
 136   1              1、定时器2中断优先级配置及芯片中断总使能
 137   1              2、PTIM231-PTIM230，中断优先级控制值从0-3依次表示优先级从最低到最高，共4
             -级优化级控制
 138   1              3、EA,芯片中断总使能
 139   1              -------------------------------------------------------------------------------------------------*
             -/
 140   1          PTIM21 = 1;
 141   1          PTIM20 = 0;                                                                                     // TIM
             -2/2中断优先级别为2
 142   1          EA = 1;
 143   1          /*  -------------------------------------------------------------------------------------------------
 144   1              配置周期值、比较值、计数值
 145   1              -------------------------------------------------------------------------------------------------*
             -/
 146   1          TIM2__CNTR = 0;
 147   1          /* -----启动计数----- */
 148   1          SetBit(TIM2_CR1, T2EN);                                                                         //启
             -计数
 149   1      }
 150          
 151          
 152          /**
 153           * @brief      电机转向检测
C51 COMPILER V9.52.0.0   RSDDETECT                                                         04/01/2023 22:13:43 PAGE 4   

 154           */
 155          void RSDFRDetect(void)
 156          {
 157   1          /* -----注意RSDCount需为IDATA数据类型----- */
 158   1          RSDDetect.RSDCount = TIM2__CNTR;
 159   1          
 160   1          if (RSDDetect.RSDCount < -7)                                                                    //正
             -
 161   1          {
 162   2              RSDDetect.RSDPeriod = (RSDDetect.RSDStepTime[0] + RSDDetect.RSDStepTime[1] + RSDDetect.RSDStepTime
             -[2] + RSDDetect.RSDStepTime[3]) >> 2;
 163   2              #if (FRMODE==1)
 164   2              {
 165   3                  RSDDetect.RSDDIR = ReadBit(TIM2_CR1, T2DIR);
 166   3                  //        ClrBit(TIM2_CR1, T2EN);                                                             
             -        //关掉定时器2
 167   3                  RSDDetect.RSDState = Reverse;
 168   3              }
 169   2              #else
                      {
                          RSDDetect.RSDDIR = !ReadBit(TIM2_CR1, T2DIR);
                          //        ClrBit(TIM2_CR1, T2EN);                                                             
             -        //关掉定时器2
                          RSDDetect.RSDState = Forward;
                      }
                      #endif
 176   2              RSDDetect.RSDFlag = 1;
 177   2          }
 178   1          else if (RSDDetect.RSDCount > 7)                                                                //反
             -
 179   1          {
 180   2              RSDDetect.RSDPeriod = (RSDDetect.RSDStepTime[0] + RSDDetect.RSDStepTime[1] + RSDDetect.RSDStepTime
             -[2] + RSDDetect.RSDStepTime[3]) >> 2;
 181   2              #if (FRMODE==1)
 182   2              {
 183   3                  RSDDetect.RSDDIR = ReadBit(TIM2_CR1, T2DIR);
 184   3                  //        ClrBit(TIM2_CR1, T2EN);                                                             
             -        //关掉定时器2
 185   3                  RSDDetect.RSDState = Forward;
 186   3              }
 187   2              #else
                      {
                          RSDDetect.RSDDIR = !ReadBit(TIM2_CR1, T2DIR);
                          //        ClrBit(TIM2_CR1, T2EN);                                                             
             -        //关掉定时器2
                          RSDDetect.RSDState = Reverse;
                      }
                      #endif
 194   2              RSDDetect.RSDFlag = 1;
 195   2          }
 196   1          else                                                                                            //多
             -判断
 197   1          {
 198   2              RSDDetect.RSDStepTime[RSDDetect.RSDStep] = TIM2__ARR;                                       //将
             -较器的读值给RSDStep
 199   2          }
 200   1          
 201   1          RSDDetect.RSDStep++;
 202   1          
 203   1          if (RSDDetect.RSDStep > 3)
 204   1          {
 205   2              RSDDetect.RSDStep = 0;
C51 COMPILER V9.52.0.0   RSDDETECT                                                         04/01/2023 22:13:43 PAGE 5   

 206   2          }
 207   1          else
 208   1          {
 209   2              ;
 210   2          }
 211   1          
 212   1          RSDDetect.RSDTimes++;                                                                           //多
             -中断，但又没有跳入正反转
 213   1          
 214   1          if (RSDDetect.RSDTimes > 15)
 215   1          {
 216   2              RSDDetect.RSDState = Static;
 217   2              RSDDetect.RSDFlag = 1;
 218   2          }
 219   1          else
 220   1          {
 221   2              ;
 222   2          }
 223   1          
 224   1          if (RSDDetect.RSDState != Static)                                                           //处理
             -度
 225   1          {
 226   2              RSDDetect.RSDSpeedBase = RSDSpeedBaseStep;
 227   2              RSDDetect.RSDPeriod += 1;
 228   2              
 229   2              //            mcFocCtrl.RSDDIVFlag = 1;
 230   2              if (mcFocCtrl.RSDDIVFlag == 0)
 231   2              {
 232   3                  RSDDetect.RSDSpeed  = MDU_DIV_IDATA_U32(&RSDDetect.RSDSpeedBase, &RSDDetect.RSDPeriod); //Q格
             -式的速度,此处除法器与过调值不冲突
 233   3                  mcFocCtrl.RSDDIVFlag = 1;           //只计算一次
 234   3              }
 235   2              
 236   2              //                      RSDDetect.RSDSpeed  = (uint16)(RSDDetect.RSDSpeedBase/RSDDetect.RSDPeriod)
             -;//MDU_DIV_IDATA_U32(&RSDDetect.RSDSpeedBase, &RSDDetect.RSDPeriod);
 237   2              //            RSDDetect.RSDFlag = 0;
 238   2          }
 239   1          
 240   1          if (RSDDetect.RSDFlag == 1)
 241   1          {
 242   2              if ((RSDDetect.RSDState == Forward) && (RSDDetect.RSDDIR == 0x00))                     //正转
 243   2              {
 244   3                  if ((RSDDetect.RSDSpeed >= _Q15(5000.0 / MOTOR_SPEED_BASE)) && (RSDDetect.RSDSpeed <= _Q15(600
             -00.0 / MOTOR_SPEED_BASE)))
 245   3                  {
 246   4                      if ((ReadBit(CMP_SR, CMP1OUT) == 0) && (ReadBit(CMP_SR, CMP0OUT) == 0))
 247   4                      {
 248   5                          ClrBit(CMP_CR2, CMP0EN);                                                              
             -  // 关闭比较器
 249   5                          ClrBit(TIM2_CR1, T2EN);                                                               
             -  // 0，停止计数；1,使能计数
 250   5                          RSDDetect.RSDFlag = 0;//顺风判断结束
 251   5                          RSDDetect.RSDTheta = _Q15((float) -90 / 180.0);                                       
             -                                                 //end    EstimateAlgorithm
 252   5                          RSDFOCCloseLoopStart();
 253   5                          //                                      BEMFFOCCloseLoopStart();
 254   5                      }
 255   4                  }
 256   3                  else if (RSDDetect.RSDSpeed < _Q15(5000.0 / MOTOR_SPEED_BASE))
 257   3                  {
 258   4                      RSDDetect.RSDFlag = 0;//顺风判断结束
 259   4                      MOE = 0;
C51 COMPILER V9.52.0.0   RSDDETECT                                                         04/01/2023 22:13:43 PAGE 6   

 260   4                      mcFocCtrl.WindFlag = 1 ;
 261   4                      ClrBit(CMP_CR2, CMP0EN);                                                                //
             - 关闭比较器
 262   4                      ClrBit(TIM2_CR1, T2EN);                                                                 //
             - 0，停止计数；1,使能计数
 263   4                  }
 264   3                  else if (RSDDetect.RSDSpeed > _Q15(60000.0 / MOTOR_SPEED_BASE))
 265   3                  {
 266   4                      mcFocCtrl.RSDDIVFlag = 0;//速度过高重新计算速度
 267   4                  }
 268   3              }
 269   2          }
 270   1      }
 271          
 272          
 273          /**
 274           * @brief      RSD顺逆风处理
 275           */
 276          void RSDDealwith(void)
 277          {
 278   1          if (RSDDetect.RSDFlag == 1)                                                                     // 转
             -向判断结束
 279   1          {
 280   2              //       if(mcFocCtrl.RSDDIVFlag == 0)//等待计算结束
 281   2              //           {
 282   2              /* -----反转超过一定速度，且刹车次数小于4次时，进入----- */
 283   2              if (((RSDDetect.RSDState == Reverse) && (RSDDetect.RSDDIR == 0x01)) && (RSDDetect.RSDSpeed > _Q15(
             -80.0 / MOTOR_SPEED_BASE)) && (RSDDetect.RSDCCWTimes < 4))
 284   2              {
 285   3                  mcFocCtrl.State_Count = 1000;          //单位：1ms
 286   3                  McStaSet.SetFlag.TailWindSetFlag = 0; // 开刹车，重新初始化RSD，重新判断是否
             -在反转或者静止？？？
 287   3                  MOE = 0;
 288   3                  DRV_DR = DRV_ARR + 1;
 289   3                  DRV_CMR &= 0xFFC0;
 290   3                  DRV_CMR |= 0x015;                                                                       // 三
             -相下桥臂通，刹车
 291   3                  ClrBit(DRV_CR, OCS);                                                                    //OCS 
             -= 0, DRV_COMR;OCS = 1, FOC/SVPWM/SPWM
 292   3                  MOE = 1;
 293   3                  
 294   3                  if (RSDDetect.RSDSpeed > _Q15(200.0 / MOTOR_SPEED_BASE))                                //速
             -超过一定值时，刹车，且置标志位，在启动时，根据不同速度设置不同启动电流
 295   3                  {
 296   4                      mcFocCtrl.State_Count = 1500; //单位：1ms
 297   4                      RSDDetect.RSDCCWFlag = 1;
 298   4                  }
 299   3                  else
 300   3                  {
 301   4                      mcFocCtrl.State_Count = 800;   //单位：1ms
 302   4                      
 303   4                      if (RSDDetect.RSDCCWFlag == 0)
 304   4                      {
 305   5                          RSDDetect.RSDCCWFlag = 2;
 306   5                      }
 307   4                  }
 308   3                  
 309   3                  RSDDetect.RSDFlag = 0;//顺风判断结束
 310   3                  RSDDetect.RSDCCWTimes++;
 311   3                  ClrBit(CMP_CR2, CMP0EN);                                                                //关
             -比较器
 312   3                  ClrBit(TIM2_CR1, T2EN);                                                                 // 0
C51 COMPILER V9.52.0.0   RSDDETECT                                                         04/01/2023 22:13:43 PAGE 7   

             -停止计数；1,使能计数
 313   3              }
 314   2              //        else if ((RSDDetect.RSDState == Forward) && (RSDDetect.RSDDIR == 0x00))                 
             -    //正转
 315   2              //        {
 316   2              //
 317   2              ////            RSDCloseDeal();
 318   2              //                  if((RSDDetect.RSDSpeed >= _Q15(5000.0 / MOTOR_SPEED_BASE))&&(RSDDetect.RSDSpee
             -d <= _Q15(60000.0 / MOTOR_SPEED_BASE)))
 319   2              //                  {
 320   2              //
 321   2              //                      if((ReadBit(CMP_SR, CMP1OUT) == 0)&&(ReadBit(CMP_SR, CMP0OUT) == 0))
 322   2              //                      {
 323   2              //
 324   2              //
 325   2              //                          ClrBit(CMP_CR2, CMP0EN);                                              
             -                  // 关闭比较器
 326   2              //                          ClrBit(TIM2_CR1, T2EN);                                               
             -                  // 0，停止计数；1,使能计数
 327   2              //
 328   2              //
 329   2              //
 330   2              //                          RSDDetect.RSDFlag = 0;//顺风判断结束
 331   2              //                          RSDDetect.RSDTheta = _Q15((float)-90 / 180.0);                        
             -                                                                 //end    EstimateAlgorithm
 332   2              ////                            RSDFOCCloseLoopStart();
 333   2              //                          BEMFFOCCloseLoopStart();
 334   2              //
 335   2              //
 336   2              //                      }
 337   2              ////                        else if((ReadBit(CMP_SR, CMP1OUT) == 0)&&(ReadBit(CMP_SR, CMP0OUT) == 
             -0))
 338   2              ////                        {
 339   2              ////                            RSDDetect.RSDTheta = _Q15((float)-90.0 / 180.0); ;
 340   2              ////                        }
 341   2              ////                        else if((ReadBit(CMP_SR, CMP1OUT) == 0)&&(ReadBit(CMP_SR, CMP0OUT) == 
             -1))
 342   2              ////                        {
 343   2              ////                            RSDDetect.RSDTheta = _Q15((float)-150.0 / 180.0); ;
 344   2              ////                        }
 345   2              ////                        else
 346   2              ////                        {
 347   2              ////                            RSDDetect.RSDTheta = _Q15((float)90.0 / 180.0); ;
 348   2              ////                        }
 349   2              //
 350   2              //
 351   2              //                  }
 352   2              //                  else if(RSDDetect.RSDSpeed < _Q15(5000.0 / MOTOR_SPEED_BASE))
 353   2              //                  {
 354   2              //                          RSDDetect.RSDFlag = 0;//顺风判断结束
 355   2              //                              MOE = 0;
 356   2              //                mcState = mcPosiCheck;
 357   2              //                McStaSet.SetFlag.PosiCheckSetFlag = 0;
 358   2              //                mcFocCtrl.mcPosCheckAngle           = 0xffff;                                   
             -    // 角度赋初值
 359   2              //
 360   2              //                            ClrBit(CMP_CR2, CMP0EN);                                            
             -                    // 关闭比较器
 361   2              //                              ClrBit(TIM2_CR1, T2EN);                                           
             -                      // 0，停止计数；1,使能计数
 362   2              //                  }
 363   2              //                  else if(RSDDetect.RSDSpeed > _Q15(60000.0 / MOTOR_SPEED_BASE))
C51 COMPILER V9.52.0.0   RSDDETECT                                                         04/01/2023 22:13:43 PAGE 8   

 364   2              //                {
 365   2              //                          mcFocCtrl.RSDDIVFlag = 0;//速度过高重新计算速度
 366   2              //                  }
 367   2              //
 368   2              //
 369   2              //
 370   2              //        }
 371   2              else  if (RSDDetect.RSDState == Static)                                                           
             -                          //其他，如静止
 372   2              {
 373   3                  RSDDetect.RSDFlag = 0;//顺风判断结束
 374   3                  ClrBit(CMP_CR2, CMP0EN);                                                                // 关
             -闭比较器
 375   3                  ClrBit(TIM2_CR1, T2EN);                                                                 // 0
             -停止计数；1,使能计数
 376   3                  
 377   3                  if (RSDDetect.RSDCCWFlag != 0)                                                          // 此
             -种情况为反转低转速的时候
 378   3                  {
 379   4                      if (RSDDetect.RSDBRFlag == 0)                                                       // 刹
             -车400ms，用以提高逆风情况下的成功率
 380   4                      {
 381   5                          RSDDetect.RSDCCWSBRCnt = 400;          //单位：1ms
 382   5                          MOE = 0; 
 383   5                          DRV_DR = DRV_ARR + 1;
 384   5                          DRV_CMR &= 0xFFC0;;
 385   5                          DRV_CMR |= 0x015;                                                               // 三
             -相下桥臂通，刹车
 386   5                          ClrBit(DRV_CR, OCS);                                                            // OCS
             - = 0, DRV_COMR;OCS = 1, FOC/SVPWM/SPWM
 387   5                          MOE = 1;
 388   5                          RSDDetect.RSDBRFlag = 1;
 389   5                      }
 390   4                  }
 391   3                  
 392   3                  if ((RSDDetect.RSDCCWFlag == 0) || (RSDDetect.RSDCCWSBRCnt == 0))
 393   3                  {
 394   4                      MOE = 0;
 395   4                      mcFocCtrl.WindFlag = 1;
 396   4                  }
 397   3              }
 398   2              
 399   2              //          }
 400   2          }
 401   1      }
 402          
 403          
 404          /**
 405           * @brief      顺风启动
 406           */
 407          void RSDFOCCloseLoopStart(void)
 408          {
 409   1          /* -----FOC初始化----- */
 410   1          FOC_Init();
 411   1          //    FOC__THECOMP  = _Q15(-10.0/180.0);
 412   1          //    FOC__UD = _Q15(0.0);
 413   1          //    FOC__UQ = _Q15(0.3);
 414   1          /* -----启动电流、KP、KI----- */
 415   1          //  FOC_IDREF = ID_Start_CURRENT;                                                               // D
             -启动电流
 416   1          //  mcFocCtrl.mcIqref= IQ_Start_CURRENT;                                                        // Q
             -启动电流
C51 COMPILER V9.52.0.0   RSDDETECT                                                         04/01/2023 22:13:43 PAGE 9   

 417   1          //  FOC_IQREF = mcFocCtrl.mcIqref;                                                              // Q
             -启动电流
 418   1          //  FOC_DQKP = DQKP;
 419   1          //  FOC_DQKI = DQKI;
 420   1          //    FOC__EOME = 10100;
 421   1          //      FOC__UQ =_Q15(0.9);
 422   1          FOC_EFREQACC    = Motor_Omega_Ramp_ACC;
 423   1          FOC_EFREQMIN    = Motor_Omega_Ramp_Min;
 424   1          FOC_EFREQHOLD = Motor_Omega_Ramp_End;
 425   1          SetBit(FOC_CR1, EFAE);                                                                          // 估
             -算器强制输出
 426   1          ClrBit(FOC_CR1, RFAE);                                                                          // 禁
             -止强拉
 427   1          SetBit(FOC_CR1, ANGM);                                                                          // 估
             -算模式
 428   1          FOC__THETA =  RSDDetect.RSDTheta;//
 429   1         #if (EstimateAlgorithm == SMO  || EstimateAlgorithm == AO)
 430   1          {
 431   2              FOC__ETHETA = FOC__THETA - 4836; //30°
 432   2          }
 433   1          #elif (EstimateAlgorithm == PLL)
                  {
                      FOC__ETHETA = FOC__THETA;//30°
                  }
                  #endif
 438   1          //    FOC__EOME = BEMFDetect.BEMFSpeed;
 439   1          RSDDetect.RSDTempSpeed = (int16)RSDDetect.RSDSpeed;
 440   1          FOC__EOME = RSDDetect.RSDTempSpeed;
 441   1          //      FOC__UQ = _Q15(0.2);
 442   1          //    FOC__EOME = RSDDetect.RSDSpeed;
 443   1          //    FOC__UQ=(QOUTMAX>>1);
 444   1          #if (EstimateAlgorithm == SMO  || EstimateAlgorithm == AO)
 445   1          {
 446   2              PI2_KP = _Q12(7.99);
 447   2              PI2_KI = _Q15(0.99);
 448   2              PI3_KP = PI2_KP;
 449   2              PI3_KI = PI2_KI;
 450   2              FOC_DQKP = _Q12(5.0);
 451   2              FOC_DQKI = _Q15(0.99) ;
 452   2              FOC_EKP                 = OBSW_KP_GAIN_RUN4;
 453   2              FOC_EKI                 = OBSW_KI_GAIN_RUN4;
 454   2              mcFocCtrl.mcIqref       = I_Value(10.0);
 455   2              mcFocCtrl.State_Count   = 10;//10   
 456   2              FOC_OMEKLPF                     = SPEED_KLPF;
 457   2              mcFocCtrl.WindFlag = 2;
 458   2              mcFocCtrl.CtrlMode              = 0;
 459   2              /* -----使能输出----- */
 460   2              DRV_CMR |= 0x3F;                                                                            // U
             -V、W相输出
 461   2              MOE = 1;
 462   2              EA = 1;
 463   2              FOC_IQREF = mcFocCtrl.mcIqref;
 464   2          }
 465   1          #elif (EstimateAlgorithm == PLL)
                  {
                      FOC_EKP                     = OBSW_KP_GAIN_RUN4;
                      FOC_EKI                     = OBSW_KI_GAIN_RUN4;
                      mcFocCtrl.mcIqref           = IQ_RUN_CURRENT;
                  }
                  #endif                                                                                          //end 
             -   EstimateAlgorithm
 472   1      }
C51 COMPILER V9.52.0.0   RSDDETECT                                                         04/01/2023 22:13:43 PAGE 10  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1222    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
