C51 COMPILER V9.52.0.0   INTERRUPT                                                         04/01/2023 22:13:42 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE INTERRUPT
OBJECT MODULE PLACED IN .\Output\Interrupt.obj
COMPILER INVOKED BY: D:\IDE\keil\C51\BIN\C51.EXE ..\User\Source\Application\Interrupt.c LARGE OMF2 WARNINGLEVEL(0) BROWS
                    -E INCDIR(..\User\Include;..\FU68xx_Hardware_Driver\Include) DEBUG PRINT(.\Listing\Interrupt.lst) TABS(2) OBJECT(.\Output
                    -\Interrupt.obj)

line level    source

   1          /**
   2           * @copyright (C) COPYRIGHT 2022 Fortiortech Shenzhen
   3           * @file      Interrupt.c
   4           * @author    Fortiortech  Appliction Team
   5           * @date      2022-07-13
   6           * @brief     This file contains interrupt function used for Motor Control.
   7           */
   8           
   9          
  10          
  11          #include <FU68xx_2.h>
  12          #include <Myproject.h>
  13          
  14          uint16 xdata spidebug[4] = { 0 };
  15          uint16 xdata Power_Currt;
  16          
  17          /** 
  18           * @brief     ä½äºé¢„è­¦ä¸­æ–­
  19           *            å¼€å¯ä½å‹æ£€æµ‹ä¸­æ–­å,MCUä¼šå¯¹è¾“å…¥ç”µå‹è¿›è¡Œç›‘æµ‹,å½“è¾“å…¥ç”µå‹ä½äºè®¾å®šå€¼
             -ï¼Œåˆ™ä¼šè§¦å‘ä¸­æ–­
  20           */
  21          void LVW_INT(void) interrupt 0                                                                      // ç¡¬
             -ä»¶FOè¿‡æµä¸­æ–­ï¼Œå…³é—­è¾“å‡º
  22          {
  23   1          mcFaultSource = FaultLVW;                                                                       // ç¡¬
             -ä»¶è¿‡æµä¿æŠ¤
  24   1          ClrBit(LVSR, LVWIF);
  25   1      }
  26          
  27          
  28          /** 
  29           * @brief        æ¯”è¾ƒå™¨3ç¡¬ä»¶è¿‡æµä¿æŠ¤ï¼Œè¯¥ä¸­æ–­ä»…æä¾› æ•…éšœç  èµ‹å€¼,ç”¨äºçŠ¶æ€æœºçš„åˆ‡æ
             -¢ã€‚
  30           *               éœ€è¦å¼€å¯æ¯”è¾ƒå™¨CMP3  å‘ç”Ÿè¿‡æµè‡ªåŠ¨æ¸…é™¤MOEåŠŸèƒ½
  31           * @brief        CMP0/1/2ï¼šé¡ºé€†é£åˆ¤æ–­  
  32           */
  33          void CMP_ISR(void) interrupt 7
  34          {
  35   1          if (ReadBit(CMP_SR, CMP3IF))
  36   1          {
  37   2              MOE = 0;
  38   2              mcFaultSource = FaultHardOVCurrent;                                 // ç¡¬ä»¶è¿‡æµä¿æŠ¤
  39   2              ClrBit(CMP_SR, CMP3IF);
  40   2          }
  41   1          
  42   1          #if (TailWind_Mode == BEMFMethod)
  43   1          {
  44   2              /* -----é€šè¿‡BEMFåšé¡ºé£å¯åŠ¨åŠŸèƒ½----- */
  45   2              BEMFDetectFunc();
  46   2          }
  47   1          #endif
  48   1      }
  49          
C51 COMPILER V9.52.0.0   INTERRUPT                                                         04/01/2023 22:13:42 PAGE 2   

  50          
  51          /** 
  52           * @brief        FOCä¸­æ–­(Drvä¸­æ–­),æ¯ä¸ªè½½æ³¢å‘¨æœŸæ‰§è¡Œä¸€æ¬¡ï¼Œç”¨äºå¤„ç†å“åº”è¾ƒé«˜çš„ç¨‹åºï¼
             -Œä¸­æ–­ä¼˜å…ˆçº§ç¬¬äºŒ
  53           */
  54          void FOC_INT(void) interrupt 3
  55          {
  56   1          //      GP05 = 1;
  57   1          if (ReadBit(DRV_SR, DCIF))                                                                      // æ¯”
             -è¾ƒä¸­æ–­
  58   1          {
  59   2              /* -----å¯åŠ¨é™¤æ³•å™¨----- */
  60   2              APP_DIV();                                                                                  // å¯
             -åŠ¨é™¤æ³•å™¨ï¼Œé¿å…ä¸è¿‡è°ƒå€¼ä¸­çš„é™¤æ³•å†²çª
  61   2              //            if((mcState == mcStart)||(mcState == mcRun))
  62   2              //            if((mcState != mcAlign))
  63   2              //              {
  64   2              //                  CurrentLoop();
  65   2              //              }
  66   2              StartupState();
  67   2              #if defined (SPI_DBG_SW)                                                                    // è½¯
             -ä»¶è°ƒè¯•æ¨¡å¼
                      {
                          spidebug[0] = SOFT_SPIDATA0;
                          spidebug[1] = SOFT_SPIDATA1;
                          spidebug[2] = SOFT_SPIDATA2;
                          spidebug[3] = SOFT_SPIDATA3;
                      }
                      #endif
  75   2              DRV_SR = (DRV_SR | SYSTIF) & (~DCIF);
  76   2          }
  77   1          
  78   1          //      GP05 = 0;
  79   1      }
  80          
  81          
  82          /**
  83           * @brief    æ­£åè½¬æ£€æµ‹(RSD)
  84           */
  85          void TIM2_INT(void) interrupt 4
  86          {
  87   1          if (ReadBit(TIM2_CR1, T2IR))
  88   1          {
  89   2              ClrBit(TIM2_CR1, T2IR);
  90   2          }
  91   1          
  92   1          if (ReadBit(TIM2_CR1, T2IP))
  93   1          {
  94   2              #if (TailWind_Mode == RSDMethod)
                      {
                          RSDFRDetect();                                                                          //RSDæ
             -­£åè½¬æ£€æµ‹
                      }
                      #endif
  99   2              ClrBit(TIM2_CR1, T2IP);
 100   2          }
 101   1          
 102   1          if (ReadBit(TIM2_CR1, T2IF))                                                                    //æº¢å
             -‡ºä¸­æ–­,ç”¨äºåˆ¤æ–­é™æ­¢,æ—¶é—´ä¸º349msã€‚
 103   1          {
 104   2              #if (TailWind_Mode == RSDMethod)
                      {
C51 COMPILER V9.52.0.0   INTERRUPT                                                         04/01/2023 22:13:42 PAGE 3   

                          RSDDetect.RSDState = Static;
                          RSDDetect.RSDFlag  = 1;
                      }
                      #endif
 110   2              ClrBit(TIM2_CR1, T2IF);
 111   2          }
 112   1      }
 113          
 114          
 115          /**
 116           * @brief    PWMæ•è· ï¼Œä¸­æ–­ä¼˜å…ˆçº§ç¬¬äºŒï¼Œé«˜äºFOCä¸­æ–­ï¼Œç”¨äºPWMè°ƒé€Ÿ
 117           */
 118          void TIM3_INT(void) interrupt 9
 119          {
 120   1          if (ReadBit(TIM3_CR1, T3IR))
 121   1          {
 122   2              ClrBit(TIM3_CR1, T3IR);
 123   2          }
 124   1          
 125   1          if (ReadBit(TIM3_CR1, T3IP))                                                                  //å‘¨æœŸ
             -ä¸­æ–­
 126   1          {
 127   2              if (mcPwmInput.PWMFlag != 1)                                                              //è‹¥æ­£
             -åœ¨è®¡ç®—å ç©ºæ¯”åˆ™ä¸æ›´æ–°
 128   2              {
 129   3                  mcPwmInput.PWMCompare    = TIM3__DR;
 130   3                  mcPwmInput.PWMARR        = TIM3__ARR;
 131   3                  mcPwmInput.PWMUpdateFlag = 1;
 132   3              }
 133   2              
 134   2              ClrBit(TIM3_CR1, T3IP);
 135   2          }
 136   1          
 137   1          if (ReadBit(TIM3_CR1, T3IF))
 138   1          {
 139   2              if (GP11)                                                                                 //PWM 10
             -0%è¾“å‡º
 140   2              {
 141   3                  mcPwmInput.PWMCompare = 8000;
 142   3                  mcPwmInput.PWMARR     = 8000;
 143   3              }
 144   2              else                                                                                      //PWM ä¸
             -º0%
 145   2              {
 146   3                  mcPwmInput.PWMCompare = 0;
 147   3                  mcPwmInput.PWMARR     = 8000;
 148   3              }
 149   2              
 150   2              mcPwmInput.PWMUpdateFlag = 1;
 151   2              ClrBit(TIM3_CR1, T3IF);
 152   2          }
 153   1      }
 154          
 155          
 156          /**
 157           * @brief    1msä¸­æ–­ï¼Œç”¨äºäº§ç”Ÿ1mså®šæ—¶é—´éš”
 158           */
 159          void SYStick_INT(void) interrupt 10
 160          {
 161   1      
 162   1          if (ReadBit(DRV_SR, SYSTIF))                                                                    // SYS
             - TICKä¸­æ–­
C51 COMPILER V9.52.0.0   INTERRUPT                                                         04/01/2023 22:13:42 PAGE 4   

 163   1          {
 164   2              VariableFlag.g_1msTick = 1;
 165   2              DRV_SR = (DRV_SR | DCIF) & (~SYSTIF);                                     // æ¸…é›¶æ ‡å¿—ä½
 166   2          }
 167   1      }
 168          
 169          
 170          /**
 171           * @brief     ä¸²å£ä¸­æ–­ï¼Œä¸­æ–­ä¼˜å…ˆçº§æœ€ä½ï¼Œç”¨äºæ¥æ”¶ä¸²å£ä¿¡å·
 172           */
 173          void USART_INT(void)  interrupt 12
 174          {
 175   1          //    if(RI == 1)
 176   1          //    {
 177   1          //        RI = 0;
 178   1          //        Uart.Uredata= UT_DR;                                                                  //è¯»æ
             -¥æ”¶æ•°æ®
 179   1          //        UartRecIsr();
 180   1          //    }
 181   1          //    if (TI == 1)
 182   1          //    {
 183   1          //        TI = 0;
 184   1          ////        UT_DR = 0xaa;
 185   1          //        UartSendIsr();
 186   1          //    }
 187   1      }
 188          
 189          
 190          /**
 191           * @brief    ç¡çœ å”¤é†’ä¸­æ–­
 192           */
 193          void EXTERN_INT(void) interrupt 2
 194          {
 195   1          if (SleepSet.SleepFlag)
 196   1          {
 197   2              SleepSet.SleepFlag = 0;
 198   2              SleepSet.SleepEn   = 1;
 199   2          }
 200   1          
 201   1          ClrBit(P1_IF, P11);                                                                             // æ¸…
             -é›¶P10æ ‡å¿—ä½
 202   1      }
 203          
 204          
 205          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    447    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
