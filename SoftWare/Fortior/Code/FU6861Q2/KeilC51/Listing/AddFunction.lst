C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE ADDFUNCTION
OBJECT MODULE PLACED IN .\Output\AddFunction.obj
COMPILER INVOKED BY: D:\IDE\keil\C51\BIN\C51.EXE ..\User\Source\Application\AddFunction.c LARGE OMF2 WARNINGLEVEL(0) BRO
                    -WSE INCDIR(..\User\Include;..\FU68xx_Hardware_Driver\Include) DEBUG PRINT(.\Listing\AddFunction.lst) TABS(2) OBJECT(.\Ou
                    -tput\AddFunction.obj)

line level    source

   1          /*
   2           * @Author: Yanke@zjut.edu.cn
   3           * @Date: 2023-03-20 21:07:44
   4           * @LastEditors: LINKEEE 1435020085@qq.com
   5           * @LastEditTime: 2023-04-01 21:38:57
   6           * @FilePath: \Software\User\Source\Application\AddFunction.c
   7           */
   8          /**
   9           * @copyright (C) COPYRIGHT 2022 Fortiortech Shenzhen
  10           * @file      AddFunction.c
  11           * @author    Fortiortech  Appliction Team
  12           * @since     Create:2022-07-13
  13           * @date      Last modify:2022-07-14
  14           * @brief     This file contains main function used for Motor Control.
  15           */
  16          
  17          /* -----Includes----- */
  18          #include <FU68xx_2.h>
  19          #include <Myproject.h>
  20          #include "MyFunction.h"
  21          #include "MyVariable.h"
  22          /* -----Private variables----- */
  23          PWMINPUTCAL idata mcPwmInput;       ///< PWMæ•è·ç»“æ„ä½“å˜é‡
  24          MotorRSDTypeDef idata RSDDetect;    ///< RSDé¡ºé€†é£æ£€æµ‹ç»“æ„ä½“å˜é‡
  25          FaultStateType xdata mcFaultSource; ///< é”™è¯¯ä¿¡æ¯ç»“æ„ä½“å˜é‡
  26          FOCCTRL xdata mcFocCtrl;            ///< FOCç”µæœºæ§åˆ¶ç›¸å…³ç»“æ„ä½“å˜é‡
  27          ADCSample xdata AdcSampleValue;     ///< ADCç›¸å…³ç»“æ„ä½“å˜é‡
  28          ONVarible xdata ONOFFTest;          ///< ONOFFå¯åœæµ‹è¯•å°å·¥å…·ç»“æ„ä½“å˜é‡
  29          MCLedDisplay xdata mcLedDisplay;    ///< LEDç¯æ§åˆ¶ç»“æ„ä½“å˜é‡
  30          MCRAMP xdata mcSpeedRamp;           ///< æ§åˆ¶æŒ‡ä»¤çˆ¬å¡ç»“æ„ä½“ç›¸å…³å˜é‡
  31          SLEEPMODE xdata SleepSet;           ///< ç¡çœ æ¨¡å¼æ§åˆ¶ç»“æ„ä½“å˜é‡
  32          MotorFRTypeDef xdata mcFRState;     ///< æ–¹å‘æ§åˆ¶ç»“æ„ä½“å˜é‡
  33          KeyScanParam_TypeDef xdata KS;      ///< æŒ‰é”®æ§åˆ¶ç»“æ„ä½“å˜é‡
  34          Flag_VARIABLE xdata VariableFlag;   ///< æ ‡å¿—ä½æ§åˆ¶ç»“æ„ä½“å˜é‡
  35          int16 xdata VSP;
  36          int16 Motor_Loop_Speed1;
  37          uint16 PI_Count = 0;
  38          uint32 TempPower;
  39          
  40          const int16 PowerGiven[10] = {0, 500, 1000, 2200, 2900, 4300, 5900, 7300, 7900, 8550};
  41          
  42          /**
  43           * @brief     æ»¤æ³¢
  44           * @param[in]   INVlaue
  45           * @param[out]  OutLastValue
  46           */
  47          int16 KLPF_VALUE(int16 INVlaue, int16 OutLastValue)
  48          {
  49   1          int16 Result = 0;
  50   1          MDU_MA = (INVlaue - OutLastValue);
  51   1          MDU_MB = (int16)480; // å†™è¢«ä¹˜æ•°å’Œä¹˜æ•°
  52   1          Result = MDU_MB;
  53   1          Result += OutLastValue;
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 2   

  54   1          return (Result);
  55   1      }
  56          
  57          /**
  58            @brief        ä¿æŠ¤å¤„ç†å‡½æ•°ï¼Œå…³é—­FOCè¾“å‡º
  59           */
  60          void FaultProcess(void)
  61          {
  62   1          MOE = 0;
  63   1          ClrBit(DRV_CR, FOCEN);
  64   1      }
  65          
  66          /**
  67              @brief        å¯¹å˜é‡å–16ä½çš„ç»å¯¹å€¼
  68              @param[in]    value
  69              @return       ç»å¯¹å€¼
  70          */
  71          uint16 Abs_F16(int16 value)
  72          {
  73   1          if (value < 0)
  74   1          {
  75   2              return (-value);
  76   2          }
  77   1          else
  78   1          {
  79   2              return (value);
  80   2          }
  81   1      }
  82          
  83          /**
  84              @brief        å¯¹å˜é‡å–32ä½çš„ç»å¯¹å€¼
  85              @param[in]    value
  86              @return       ç»å¯¹å€¼
  87          */
  88          uint32 Abs_F32(int32 value)
  89          {
  90   1          if (value < 0)
  91   1          {
  92   2              return (-value);
  93   2          }
  94   1          else
  95   1          {
  96   2              return (value);
  97   2          }
  98   1      }
  99          /**
 100              @brief        é™¤æ³•å½’ç±»ï¼Œå°†æ‰€æœ‰ç”¨åˆ°é™¤æ³•çš„åœ°æ–¹ï¼Œæ”¾åœ¨åŒä¸€ä¸ªä¸­æ–­ï¼Œä»¥é¿å…ä¸­æ–­ä
             -¸²æ‰°
 101          */
 102          void APP_DIV(void)
 103          {
 104   1          uint32 idata Temp32 = 0;
 105   1      
 106   1          if (mcPwmInput.PWMDivFlag == 1) // å¯åŠ¨é™¤æ³•å™¨ï¼Œé¿å…ä¸è¿‡è°ƒå€¼ä¸­çš„é™¤æ³•å†²çª
 107   1          {
 108   2              MDU_MUL_IDATA_U32(mcPwmInput.PWMCompareUpdate, 32767, &Temp32);
 109   2              mcPwmInput.PWMDuty = MDU_DIV_IDATA_U32(&Temp32, &mcPwmInput.PWMARRUpdate);
 110   2              mcPwmInput.PWMDivFlag = 0;
 111   2          }
 112   1      
 113   1      //    if( mcFocCtrl.ESDIVFlag==1)                                                           //å¯åŠ¨é™¤æ³•
             -å™¨ï¼Œé¿å…ä¸è¿‡è°ƒå€¼ä¸­çš„é™¤æ³•å†²çª
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 3   

 114   1      //    {
 115   1      //       mcFocCtrl.SQUSpeedDIVEs = MDU_DIV_XDATA_U32(&mcFocCtrl.SQUSysSpeed,&mcFocCtrl.EsValue);
 116   1      //       mcFocCtrl.ESDIVFlag=0;
 117   1      //    }
 118   1      #if (TailWind_Mode == RSDMethod)
                  {
                      //        if(mcFocCtrl.RSDDIVFlag==1)                                                           //
             -å¯åŠ¨é™¤æ³•å™¨ï¼Œé¿å…ä¸è¿‡è°ƒå€¼ä¸­çš„é™¤æ³•å†²çª
                      //        {
                      ////           RSDDetect.RSDSpeed  = MDU_DIV_IDATA_U32(&RSDDetect.RSDSpeedBase, &RSDDetect.RSDPeri
             -od); //Qæ ¼å¼çš„é€Ÿåº¦,æ­¤å¤„é™¤æ³•å™¨ä¸è¿‡è°ƒå€¼ä¸å†²çª
                      //           mcFocCtrl.RSDDIVFlag=0;
                      //        }
                  }
              #endif
 127   1      }
 128          
 129          /**
 130           * @brief    è½¯ä»¶ç”µæµç¯
 131           */
 132          void CurrentLoop(void)
 133          {
 134   1          PI2_EK = FOC_IDREF - FOC__ID; // å¡«å…¥EK
 135   1          SMDU_RunBlock(2, PI);
 136   1          FOC__UD = PI2_UKH;
 137   1          PI3_EK = FOC_IQREF - FOC__IQ;
 138   1          SMDU_RunBlock(3, PI);
 139   1          FOC__UQ = PI3_UKH;
 140   1      }
 141          
 142          /**
 143           * @brief    è¾“å…¥PWMå¤„ç†
 144           */
 145          void PWMInputCapture(void)
 146          {
 147   1          uint16 MotorControlVSP;
 148   1      
 149   1          if (mcPwmInput.PWMUpdateFlag == 1) // æœ‰æ–°çš„dutyæ›´æ–°
 150   1          {
 151   2              if ((Abs_F32(mcPwmInput.PWMCompare - mcPwmInput.PWMCompareOld) < 50) // ä¸¤æ¬¡æ¯”è¾ƒå€¼ç›¸è¿‘ï¼Œå‡
             -å°‘è¯»é”™ç‡
 152   2                  && (Abs_F32(mcPwmInput.PWMARROld - mcPwmInput.PWMARR) < 50)      // ä¸¤æ¬¡å‘¨æœŸå€¼ç›¸è¿‘ï¼Œå‡
             -å°‘è¯»é”™ç‡
 153   2                  //        &&((100<mcPwmInput.PWMARR)&&(mcPwmInput.PWMARR<6000))                     // å‘¨æœŸå
             -€¼åœ¨ä¸€å®šèŒƒå›´å†…æ‰è®¤ä¸ºæœ‰æ•ˆï¼Œå³ä¸€å®šé¢‘ç‡èŒƒå›´
 154   2                  && (mcPwmInput.PWMDivFlag == 0))
 155   2              {
 156   3                  mcPwmInput.PWMFlag = 1;                              // PWMFlagç½®1æœŸé—´ï¼Œä¸è¯»å–TIM3__DRå
             -’ŒTIM3__ARR;ï¼Œé˜²æ­¢å‡ºé”™
 157   3                  mcPwmInput.PWMCompareUpdate = mcPwmInput.PWMCompare; // å¯¹å…¶ä¹˜ä»¥32768
 158   3                  mcPwmInput.PWMARRUpdate = mcPwmInput.PWMARR;
 159   3                  mcPwmInput.PWMFlag = 0;
 160   3                  mcPwmInput.PWMDivFlag = 1; // å¯åŠ¨é™¤æ³•
 161   3      #if (PWMDUTY_Choose == NegaPWMDUTY)    // é€Ÿåº¦éšPWMå¢å¤§è€Œå¢å¤§
                          {
                              MotorControlVSP = 32767 - mcPwmInput.PWMDuty;
                          }
              #elif (PWMDUTY_Choose == PosiPWMDUTY) // é€Ÿåº¦éšPWMå¢å¤§è€Œå‡å°
 166   3                  {
 167   4                      MotorControlVSP = mcPwmInput.PWMDuty;
 168   4                  }
 169   3      #endif
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 4   

 170   3      
 171   3                  if ((MotorControlVSP > ONPWMDuty) && (MotorControlVSP <= (OFFPWMDutyHigh)))
 172   3                  {
 173   4                      mcSpeedRamp.MotorOffFilter = MotorOffFilterTime;
 174   4      
 175   4                      if (mcSpeedRamp.MotorOnFilter == 0)
 176   4                      {
 177   5                          mcSpeedRamp.MotorOnFilter = MotorOnFilterTime;
 178   5                          mcSpeedRamp.FlagONOFF = 1;
 179   5                      }
 180   4                  }
 181   3                  else if ((MotorControlVSP < OFFPWMDuty) || (MotorControlVSP > OFFPWMDutyHigh))
 182   3                  {
 183   4                      mcSpeedRamp.MotorOnFilter = MotorOnFilterTime;
 184   4      
 185   4                      if (mcSpeedRamp.MotorOffFilter == 0)
 186   4                      {
 187   5                          mcSpeedRamp.MotorOffFilter = MotorOffFilterTime;
 188   5                          mcSpeedRamp.FlagONOFF = 0;
 189   5                      }
 190   4                  }
 191   3      
 192   3                  /* -----è½¬é€Ÿæ›²çº¿è®¡ç®—----- */
 193   3                  if (mcSpeedRamp.FlagONOFF == 1)
 194   3                  {
 195   4      #if (Motor_Control_Mode == SPEED_LOOP_CONTROL)
 196   4                      {
 197   5                          if (MotorControlVSP <= MINPWMDuty)
 198   5                          {
 199   6                              mcSpeedRamp.TargetValue = Motor_Min_Speed;
 200   6                          }
 201   5                          else if (MotorControlVSP < MAXPWMDuty)
 202   5                          {
 203   6                              mcSpeedRamp.TargetValue = Motor_Min_Speed + SPEED_K * (MotorControlVSP - MINPWMDut
             -y);
 204   6                          }
 205   5                          else
 206   5                          {
 207   6                              mcSpeedRamp.TargetValue = Motor_Max_Speed;
 208   6                          }
 209   5                      }
 210   4      #elif (Motor_Control_Mode == POWER_LOOP_CONTROL)
                              {
                                  if (MotorControlVSP <= MINPWMDuty)
                                  {
                                      mcSpeedRamp.TargetValue = Motor_Min_Power;
                                  }
                                  else if (MotorControlVSP < MAXPWMDuty)
                                  {
                                      mcSpeedRamp.TargetValue = Motor_Min_Power + POWER_K * (MotorControlVSP - MINPWMDut
             -y);
                                  }
                                  else
                                  {
                                      mcSpeedRamp.TargetValue = Motor_Max_Power;
                                  }
                              }
              #elif (Motor_Control_Mode == CURRENT_LOOP_CONTROL)
                              {
                                  if (MotorControlVSP <= MINPWMDuty)
                                  {
                                      mcSpeedRamp.TargetValue = Motor_Min_Current;
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 5   

                                  }
                                  else if (MotorControlVSP < MAXPWMDuty)
                                  {
                                      mcSpeedRamp.TargetValue = Motor_Min_Current + POWER_K * (MotorControlVSP - MINPWMD
             -uty);
                                  }
                                  else
                                  {
                                      mcSpeedRamp.TargetValue = Motor_Max_Current;
                                  }
                              }
              #endif
 241   4                  }
 242   3                  else
 243   3                  {
 244   4                      mcSpeedRamp.TargetValue = 0;
 245   4                  }
 246   3              }
 247   2      
 248   2              mcPwmInput.PWMCompareOld = mcPwmInput.PWMCompare; // å°†æ­¤æ¬¡æ¯”è¾ƒå€¼èµ‹å€¼ç»™ä¸Šæ¬¡æ¯”è¾ƒå€¼
 249   2              mcPwmInput.PWMARROld = mcPwmInput.PWMARR;         // å°†æ­¤æ¬¡å‘¨æœŸå€¼èµ‹å€¼ç»™ä¸Šæ¬¡å‘¨æœŸå€¼
 250   2              mcPwmInput.PWMUpdateFlag = 0;
 251   2          }
 252   1      }
 253          
 254          /**
 255           * @brief    å¯åŠ¨æµ‹è¯•
 256           */
 257          void ONOFF_Starttest()
 258          {
 259   1          if (ONOFFTest.ONOFF_Flag == 1)
 260   1          {
 261   2              ONOFFTest.ON_Count++;
 262   2      
 263   2              if (ONOFFTest.ON_Count > StartON_Time)
 264   2              {
 265   3                  ONOFFTest.ON_Count = 0;
 266   3                  ONOFFTest.ONOFF_Times++;
 267   3                  ONOFFTest.ONOFF_Flag = 0;
 268   3                  mcSpeedRamp.FlagONOFF = 0;
 269   3                  mcSpeedRamp.TargetValue = 0;
 270   3              }
 271   2          }
 272   1          else
 273   1          {
 274   2              if (mcState != mcFault)
 275   2              {
 276   3                  ONOFFTest.OFF_Count++;
 277   3      
 278   3                  if (ONOFFTest.OFF_Count > StartOFF_Time)
 279   3                  {
 280   4                      ONOFFTest.OFF_Count = 0;
 281   4                      ONOFFTest.ONOFF_Flag = 1;
 282   4                      mcSpeedRamp.FlagONOFF = 1;
 283   4      #if (Motor_Control_Mode == SPEED_LOOP_CONTROL)
 284   4                      {
 285   5                          mcSpeedRamp.TargetValue = MOTOR_Onoff_Speed;
 286   5                      }
 287   4      #elif (Motor_Control_Mode == POWER_LOOP_CONTROL)
                              {
                                  mcSpeedRamp.TargetValue = Motor_ONOFF_Power;
                              }
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 6   

              #elif (Motor_Control_Mode == CURRENT_LOOP_CONTROL)
                              {
                                  mcSpeedRamp.TargetValue = Motor_ONOFF_Current;
                              }
              #endif
 296   4                  }
 297   3              }
 298   2          }
 299   1      }
 300          
 301          /**
 302           * @brief        å¤–éƒ¨é—­ç¯æ§åˆ¶å‡½æ•°ï¼Œç¤ºä¾‹ä»£ç æä¾› ç”µæµç¯ï¼Œé€Ÿåº¦ç¯ï¼ŒåŠŸç‡ç¯ï¼Œå¯æ ¹æ
             -®éœ€è¦è‡ªè¡Œä¿®æ”¹
 303           *               å»ºè®®ä½¿ç”¨é»˜è®¤1mså‘¨æœŸè¿è¡Œ
 304           */
 305          void Speed_response(void)
 306          {
 307   1          if ((mcState == mcRun) || (mcState == mcStop))
 308   1          {
 309   2              switch (mcFocCtrl.CtrlMode)
 310   2              {
 311   3              case 0:
 312   3              {
 313   4                  if (mcFocCtrl.SpeedFlt > Motor_Loop_Speed)
 314   4                  {
 315   5                      mcFocCtrl.CtrlMode = 1;
 316   5                      FOC_DQKP = DQKP;
 317   5                      FOC_DQKI = DQKI;
 318   5                      mcFocCtrl.mcIqref = FOC_IQREF;
 319   5      #if (Motor_Control_Mode == CURRENT_LOOP_CONTROL)
                              {
                                  mcSpeedRamp.ActualValue = mcFocCtrl.mcIqref;
                              }
              #elif (Motor_Control_Mode == SPEED_LOOP_CONTROL)
 324   5                      {
 325   6                          mcSpeedRamp.ActualValue = FOC__EOME;
 326   6                      }
 327   5      #elif (Motor_Control_Mode == POWER_LOOP_CONTROL)
                              {
                                  mcSpeedRamp.ActualValue = mcFocCtrl.Powerlpf;
                              }
              #endif
 332   5                      mcFocCtrl.TorqueLoopTime = SPEED_LOOP_TIME;
 333   5                      PI1_UKH = mcFocCtrl.mcIqref;
 334   5                      //                    FOC_IQREF = IQ_RUN_CURRENT;
 335   5                      //                                      PI1_UKH = IQ_RUN_CURRENT;
 336   5                      //                    mcSpeedRamp.ActualValue = mcFocCtrl.Powerlpf;
 337   5                  }
 338   4              }
 339   3              break;
 340   3      
 341   3              case 1:
 342   3              {
 343   4                  mcFocCtrl.TorqueLoopTime++;
 344   4      
 345   4                  if (mcFocCtrl.TorqueLoopTime >= SPEED_LOOP_TIME)
 346   4                  {
 347   5                      mcFocCtrl.TorqueLoopTime = 0;
 348   5                      mc_ramp();
 349   5      #if (Motor_Control_Mode == CURRENT_LOOP_CONTROL)
                              {
                                  mcFocCtrl.mcIqref = mcSpeedRamp.ActualValue;
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 7   

                                  FOC_IQREF = mcFocCtrl.mcIqref;
                              }
              #elif (Motor_Control_Mode == SPEED_LOOP_CONTROL)
 355   5                      {
 356   6                          FOC_IQREF = HW_One_PI(mcSpeedRamp.ActualValue - mcFocCtrl.SpeedFlt); // COMPESATEæ˜¯ä½
             -œä¸ºè¡¥å¿
 357   6                      }
 358   5      #elif (Motor_Control_Mode == POWER_LOOP_CONTROL)
                              {
              #if (OverSpeedLimitEnable) // é™é€Ÿ
                                  {
                                      FOC_QMAX = PIDControl(&SpeedPID, Motor_Limit_Speed, mcFocCtrl.SpeedFlt);
                                  }
              #endif
                                  //                            FOC_IQREF = PIDControl(&SpeedPID,mcSpeedRamp.ActualValue
             -,mcFocCtrl.Powerlpf);
                                  // æ³¨æ„ï¼ï¼ï¼ä¸‹é¢è¿™å¥ä»£ç è°ƒç”¨çš„æ—¶å€™ 32ä½ä¹˜æ³•å™¨çš„ç»“æœå³ç§»12ä½
             - ä¸PWMè®¡ç®—ä¸éœ€è¦æœ‰è¾¹ç§»æœ‰å†²çª
                                  //                            FOC_IQREF = PID_Control(&SpeedPID,mcSpeedRamp.ActualValu
             -e,mcFocCtrl.Powerlpf);
                                  FOC_IQREF = HW_One_PI(mcSpeedRamp.ActualValue - mcFocCtrl.Powerlpf); // åŠ è¿™å¥è¯ä¸
             -ºä»€ä¹ˆActualValueå€¼ä¼šå˜
                              }
              #endif
 371   5      
 372   5                      if (FOC_EK2 < OBS_K2T_Actual - 10)
 373   5                      {
 374   6                          mcFocCtrl.Smo_EK2 = FOC_EK2;
 375   6                          mcFocCtrl.Smo_EK2 += 10;
 376   6                          FOC_EK2 = mcFocCtrl.Smo_EK2;
 377   6                      }
 378   5                      else if (FOC_EK2 > OBS_K2T_Actual + 10)
 379   5                      {
 380   6                          mcFocCtrl.Smo_EK2 = FOC_EK2;
 381   6                          mcFocCtrl.Smo_EK2 -= 10;
 382   6                          FOC_EK2 = mcFocCtrl.Smo_EK2;
 383   6                      }
 384   5                      else
 385   5                      {
 386   6                          FOC_EK2 = OBS_K2T_Actual;
 387   6                      }
 388   5                  }
 389   4              }
 390   3              break;
 391   3              }
 392   2          }
 393   1      
 394   1          if (mcState == mcRun)
 395   1          {
 396   2              if (mcFocCtrl.RunStateCnt < 15000) // 15sçš„å»¶è¿Ÿï¼Œç”¨äºæ¸…RSDCCWFlag,BEMFCCWFlag
 397   2              {
 398   3                  mcFocCtrl.RunStateCnt++;
 399   3              }
 400   2              else
 401   2              {
 402   3                  BEMFDetect.BEMFCCWFlag = 0;
 403   3                  RSDDetect.RSDCCWFlag = 0;
 404   3              }
 405   2          }
 406   1      }
 407          
 408          /**
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 8   

 409           * @brief        è½¯ä»¶ä½é€šæ»¤æ³¢
 410           * @param[in]    Xn1
 411           * @param[in]    Xn0
 412           * @param[in]    K
 413           * @return       æ»¤æ³¢ç»“æœ
 414           */
 415          int16 SoftLPF(int16 Xn1, int16 Xn0, int16 K)
 416          {
 417   1          int16 Temp16 = 0;
 418   1          int32 Temp32 = 0;
 419   1          Temp32 = (((int32)Xn1 - (int32)Xn0) * (int32)K) >> 15;
 420   1          Temp16 = Xn0 + (int16)Temp32;
 421   1          return Temp16;
 422   1      }
 423          
 424          /**
 425           * @brief    LEDç¯æ˜¾ç¤º
 426           */
 427          void LED_Display(void)
 428          {
 429   1          switch (mcFaultSource)
 430   1          {
 431   2          case FaultNoSource:
 432   2              ResetLEDPin;
 433   2              break;
 434   2      
 435   2          case FaultHardOVCurrent:
 436   2              Led_OnOff(1);
 437   2              break;
 438   2      
 439   2          case FaultSoftOVCurrent:
 440   2              Led_OnOff(2);
 441   2              break;
 442   2      
 443   2          case FaultUnderVoltage:
 444   2              Led_OnOff(3);
 445   2              break;
 446   2      
 447   2          case FaultOverVoltage:
 448   2              Led_OnOff(4);
 449   2              break;
 450   2      
 451   2          case FaultLossPhase:
 452   2              Led_OnOff(5);
 453   2              break;
 454   2      
 455   2          case FaultStall:
 456   2              Led_OnOff(6);
 457   2              break;
 458   2      
 459   2          case FaultStart:
 460   2              Led_OnOff(7);
 461   2              break;
 462   2      
 463   2          case FaultOverwind:
 464   2              Led_OnOff(8);
 465   2              break;
 466   2      
 467   2          case FaultOverHeat:
 468   2              Led_OnOff(9);
 469   2              break;
 470   2      
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 9   

 471   2          default:
 472   2              break;
 473   2          }
 474   1      }
 475          
 476          /**
 477           * @brief        LEDç¯çš„é—ªçƒ
 478           * @param[in]    htimeï¼šé—ªçƒæ—¶é—´
 479           */
 480          void Led_OnOff(uint8 htime)
 481          {
 482   1          mcLedDisplay.LedCount++;
 483   1          // if (mcLedDisplay.LedCount < mcLedDisplay.Counttime)
 484   1          mcLedDisplay.Count++;
 485   1      
 486   1          if (mcLedDisplay.Count < (htime << 10))
 487   1          {
 488   2              if ((mcLedDisplay.Count & 0x03ff) < 0x01ff)
 489   2              {
 490   3                  SetLEDPin;
 491   3              }
 492   2              else
 493   2              {
 494   3                  ResetLEDPin;
 495   3              }
 496   2          }
 497   1          else if (mcLedDisplay.Count < ((htime << 10) + 2000))
 498   1          {
 499   2              SetLEDPin;
 500   2          }
 501   1          else
 502   1          {
 503   2              mcLedDisplay.LedCount = 0;
 504   2              mcLedDisplay.LedTimCot = 0;
 505   2              mcLedDisplay.Count = 0;
 506   2          }
 507   1      }
 508          
 509          /**
 510           * @brief    çˆ¬å¡å‡½æ•°ï¼Œå®é™…å€¼ActualValueæ…¢æ…¢è¶‹äºç›®æ ‡å€¼TargetValue
 511           */
 512          void mc_ramp()
 513          {
 514   1          if (--mcSpeedRamp.DelayCount < 0)
 515   1          {
 516   2              mcSpeedRamp.DelayCount = mcSpeedRamp.DelayPeriod;
 517   2      
 518   2              if (mcSpeedRamp.ActualValue < mcSpeedRamp.TargetValue)
 519   2              {
 520   3                  if (mcSpeedRamp.ActualValue + Motor_Inc < mcSpeedRamp.TargetValue)
 521   3                  {
 522   4                      mcSpeedRamp.ActualValue += Motor_Inc;
 523   4                  }
 524   3                  else
 525   3                  {
 526   4                      mcSpeedRamp.ActualValue = mcSpeedRamp.TargetValue;
 527   4                  }
 528   3              }
 529   2              else
 530   2              {
 531   3                  if (mcSpeedRamp.ActualValue - Motor_Dec > mcSpeedRamp.TargetValue)
 532   3                  {
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 10  

 533   4                      mcSpeedRamp.ActualValue -= Motor_Dec;
 534   4                  }
 535   3                  else
 536   3                  {
 537   4                      mcSpeedRamp.ActualValue = mcSpeedRamp.TargetValue;
 538   4                  }
 539   3              }
 540   2          }
 541   1      }
 542          
 543          /*  -------------------------------------------------------------------------------------------------
 544              Function Name  : HW_Speed_PI
 545              Description    : é€Ÿåº¦PIå‡½æ•°
 546              Date           : 2020-08-08
 547              Parameter      : None
 548              ------------------------------------------------------------------------------------------------- */
 549          // void HW_Speed_PI(void)
 550          //{
 551          //     //      PI_EK =  mcSpeedRamp.ActualValue- mcFocCtrl.Powerlpf;                               //ç»™å®
             -šè½¬é€Ÿä¸å®é™…è½¬é€Ÿä¹‹å·®ï¼Œå¯åŒºåˆ†æ’åŠŸç‡æˆ–æ’è½¬é€Ÿï¼Œæˆ–æ’ç”µå‹
 552          //     PI_EK =  mcSpeedRamp.ActualValue - FOC__EOME;                                               //ç»™å®
             -šè½¬é€Ÿä¸å®é™…è½¬é€Ÿä¹‹å·®ï¼Œç›´æ¥å‡FOC__EOMEæœ‰é£é™©
 553          //     PI_LPF_CR |= 0x02;                                                                          // Star
             -t PI
 554          //     _nop_();  _nop_();  _nop_();  _nop_();  _nop_();
 555          //     //    mcFocCtrl.mcIqref= PI_UK;//å¯åŒºåˆ†é™åŠŸç‡ä¸ä¸é™åŠŸç‡
 556          //     //      FOC_IQREF =mcFocCtrl.mcIqref;
 557          //     PI_UK += (SKP / 4096 + 1);
 558          //     FOC_IQREF = PI_UK;
 559          // }
 560          
 561          /*  -------------------------------------------------------------------------------------------------
 562              Function Name  : HW_Genal_PI
 563              Description    : PI
 564              Date           : 2020-08-08
 565              Parameter      : Xn1: [è¾“å…¥]
 566          **                   Yn0: [è¾“å…¥]
 567          **                   Xn2: [è¾“å…¥]
 568              ------------------------------------------------------------------------------------------------- */
 569          // int16 HW_Genal_PI(int16 Xn1, int16 Yn0, int16 Xn2)
 570          //{
 571          //     PI_KP = SKP;
 572          //     PI_KI = SKI;
 573          //     PI_UKMAX = SOUTMAX;
 574          //     PI_UKMIN = SOUTMIN;
 575          //     PI_EK =  Xn1;                                                                               //åˆå§
             -‹åŒ–E(K-1)
 576          //     PI_LPF_CR |= 0x02;                                                                          // Star
             -t PI
 577          //     _nop_();  _nop_();  _nop_();  _nop_();  _nop_();
 578          //     PI_UK =  Yn0;                                                                               //åˆå§
             -‹åŒ–U(K-1)
 579          //     PI_EK =  Xn2;                                                                               //å¡«å…
             -¥EK
 580          //     PI_LPF_CR |= 0x02;                                                                          // Star
             -t PI
 581          //     _nop_();  _nop_();  _nop_();  _nop_();  _nop_();
 582          //     PI_UK += (SKP / 4096 + 1);
 583          //     return PI_UK;
 584          // }
 585          
 586          /**
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 11  

 587           * @brief        PIè¿ç®—å‡½æ•°
 588           * @param[in]    Xn1
 589           * @return       PIè¿è¡Œç»“æœ
 590           */
 591          int16 HW_One_PI(int16 Xn1)
 592          {
 593   1          PI1_EK = Xn1; // å¡«å…¥EK
 594   1          SMDU_RunBlock(1, PI);
 595   1          return PI1_UKH;
 596   1      }
 597          
 598          /**
 599           * @brief        ä½é€šæ»¤æ³¢å‡½æ•°
 600           * @param[in]    Xn1
 601           * @param[in]    Xn0
 602           * @param[in]    K
 603           * @return       æ»¤æ³¢è¾“å‡ºå€¼
 604           */
 605          int16 LPFFunction(int16 Xn1, int16 Xn0, int8 K)
 606          {
 607   1          LPF0_K = K << 8;
 608   1          LPF0_X = Xn1;
 609   1          LPF0_YH = Xn0;
 610   1          SMDU_RunBlock(0, LPF);
 611   1          return LPF0_YH;
 612   1      }
 613          
 614          /**
 615           * @brief    VSPé‡‡æ ·
 616           */
 617          void VSPSample(void)
 618          {
 619   1          /* -----VREFçš„é‡‡æ ·è·å–å€¼å¹¶æ»¤æ³¢----- */
 620   1          AdcSampleValue.ADCVref = (ADC7_DR << 3);            // é‡‡é›†å¯¹åº”ç«¯å£
 621   1          VSP = LPFFunction(AdcSampleValue.ADCVref, VSP, 10); // ä½é€šæ»¤æ³¢
 622   1      
 623   1          //    if((VSP > ONPWMDuty)&&(VSP <= OFFPWMDutyHigh))    lintè®¤ä¸ºå³è¾¹æ°¸è¿œæˆç«‹                //
             -åœ¨ONPWMDuty-OFFPWMDutyHighä¹‹é—´ï¼Œç”µæœºæœ‰è½¬é€Ÿè¿è¡Œ
 624   1          if (VSP > ONPWMDuty)
 625   1          {
 626   2              mcSpeedRamp.FlagONOFF = 1;
 627   2          }
 628   1          //    else if((VSP < OFFPWMDuty)||(VSP > OFFPWMDutyHigh))                                   //ç”µæœºå
             -œæœº lintè®¤ä¸ºå³è¾¹æ°¸è¿œä¸æˆç«‹
 629   1          else if ((VSP < OFFPWMDuty)) // ç”µæœºåœæœº
 630   1          {
 631   2              mcSpeedRamp.FlagONOFF = 0;
 632   2          }
 633   1      
 634   1          /* -----è½¬é€Ÿæ›²çº¿è®¡ç®—----- */
 635   1          if (mcSpeedRamp.FlagONOFF == 1) //
 636   1          {
 637   2      #if (Motor_Control_Mode == SPEED_LOOP_CONTROL)
 638   2              {
 639   3                  if (VSP <= MINPWMDuty)
 640   3                  {
 641   4                      mcSpeedRamp.TargetValue = Motor_Min_Speed;
 642   4                  }
 643   3                  else if (VSP < MAXPWMDuty)
 644   3                  {
 645   4                      mcSpeedRamp.TargetValue = Motor_Min_Speed + SPEED_K * (VSP - MINPWMDuty);
 646   4                  }
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 12  

 647   3                  else
 648   3                  {
 649   4                      mcSpeedRamp.TargetValue = Motor_Max_Speed;
 650   4                  }
 651   3              }
 652   2      #elif (Motor_Control_Mode == POWER_LOOP_CONTROL)
                      {
                          if (VSP <= MINPWMDuty)
                          {
                              mcSpeedRamp.TargetValue = Motor_Min_Power;
                          }
                          else if (VSP < MAXPWMDuty)
                          {
                              mcSpeedRamp.TargetValue = Motor_Min_Power + POWER_K * (VSP - MINPWMDuty);
                          }
                          else
                          {
                              mcSpeedRamp.TargetValue = Motor_Max_Power;
                          }
                      }
              #elif (Motor_Control_Mode == CURRENT_LOOP_CONTROL)
                      {
                          if (VSP <= MINPWMDuty)
                          {
                              mcSpeedRamp.TargetValue = Motor_Min_Current;
                          }
                          else if (VSP < MAXPWMDuty)
                          {
                              mcSpeedRamp.TargetValue = Motor_Min_Current + POWER_K * (VSP - MINPWMDuty);
                          }
                          else
                          {
                              mcSpeedRamp.TargetValue = Motor_Max_Current;
                          }
                      }
              #endif
 683   2          }
 684   1          else
 685   1          {
 686   2              mcSpeedRamp.TargetValue = 0;
 687   2          }
 688   1      }
 689          
 690          /**
 691           * @brief    æŒ‰é”®è°ƒé€Ÿ
 692           */
 693          void KeyScan(void)
 694          {
 695   1          if (Key0 == 0)
 696   1          {
 697   2              KS.Key0InitCnt = 0;
 698   2      
 699   2              if (KS.Key0PressCnt < 50)
 700   2              {
 701   3                  KS.Key0PressCnt++;
 702   3              }
 703   2              else
 704   2              {
 705   3                  KS.Key0PressCnt = 0;
 706   3                  KS.FlagKey0Press = 1;
 707   3                  KS.FlagKey1Press = 0;
 708   3              }
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 13  

 709   2          }
 710   1          else
 711   1          {
 712   2              KS.Key0PressCnt = 0;
 713   2      
 714   2              if (KS.Key0InitCnt < 50)
 715   2              {
 716   3                  KS.Key0InitCnt++;
 717   3              }
 718   2              else
 719   2              {
 720   3                  KS.Key0InitCnt = 0;
 721   3                  KS.FlagKey0Press = 0;
 722   3                  KS.FlagKey1Press = 1;
 723   3              }
 724   2          }
 725   1      
 726   1          if (mcSpeedRamp.FlagONOFF)
 727   1          {
 728   2              if (KS.FlagKey1Press)
 729   2              {
 730   3      //          KS.Key0PressCnt  = 0;
 731   3      //          KS.Key0InitCnt   = 0;
 732   3      #if (Motor_Control_Mode == SPEED_LOOP_CONTROL)
 733   3                  {
 734   4                      mcSpeedRamp.TargetValue = Motor_Min_Speed;
 735   4                  }
 736   3      #elif (Motor_Control_Mode == POWER_LOOP_CONTROL)
                          {
                              mcSpeedRamp.TargetValue = Motor_Min_Power;
                          }
              #elif (Motor_Control_Mode == CURRENT_LOOP_CONTROL)
                          {
                              mcSpeedRamp.TargetValue = Motor_Min_Current;
                          }
              #endif
 745   3              }
 746   2      
 747   2              if (KS.FlagKey0Press)
 748   2              {
 749   3      //          KS.Key0PressCnt  = 0;
 750   3      //          KS.Key0InitCnt   = 0;
 751   3      #if (Motor_Control_Mode == SPEED_LOOP_CONTROL)
 752   3                  {
 753   4                      mcSpeedRamp.TargetValue = Motor_Max_Speed;
 754   4                  }
 755   3      #elif (Motor_Control_Mode == POWER_LOOP_CONTROL)
                          {
                              mcSpeedRamp.TargetValue = Motor_Max_Power;
                          }
              #elif (Motor_Control_Mode == CURRENT_LOOP_CONTROL)
                          {
                              mcSpeedRamp.TargetValue = Motor_Max_Current;
                          }
              #endif
 764   3              }
 765   2          }
 766   1      }
 767          
 768          /**
 769           * @brief    ç¡çœ æ¨¡å¼
 770           */
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 14  

 771          void Sleepmode(void)
 772          {
 773   1          SleepSet.SleepDelayCout++;
 774   1      
 775   1          if (SleepSet.SleepDelayCout >= 20000) // æœ€å¤§65530ï¼Œè‹¥è¦å†å¤§ï¼Œéœ€æ”¹æ•°æ®ç±»å‹
 776   1          {
 777   2              //        FOC_EFREQMIN  = -Motor_Omega_Ramp_Min;
 778   2              //        FOC_EFREQHOLD = -Motor_Omega_Ramp_End;
 779   2              mcSpeedRamp.TargetValue = 0;
 780   2              MOE = 0;
 781   2              ClrBit(DRV_CR, FOCEN);
 782   2              SleepSet.SleepDelayCout = 0;
 783   2              SleepSet.SleepFlag = 1;
 784   2              SetBit(P1_IE, P11); // config P11 as the source of EXTI1
 785   2              SetBit(PCON, STOP);
 786   2          }
 787   1      }
 788          
 789          /**
 790           * @brief    ATO_BWçˆ¬å¡åˆ‡æ¢å‡½æ•°ï¼Œæ ¹æ®æ—¶é—´åˆ‡æ¢ATOï¼Œä½¿å…¶æ…¢æ…¢å˜å¤§
 791           */
 792          void StarRampDealwith(void)
 793          {
 794   1          //    int temp=0;
 795   1          if ((mcState == mcRun))
 796   1          {
 797   2              //            if(FOC_IQREF<mcFocCtrl.mcIqref)
 798   2              //            {
 799   2              //                temp=FOC_IQREF;
 800   2              //                temp+=20;
 801   2              //                FOC_IQREF = temp;
 802   2              //            }
 803   2              if (mcFocCtrl.State_Count == 670) // 2300
 804   2              {
 805   3                  FOC_EKP = OBSW_KP_GAIN_RUN; // ä¼°ç®—å™¨é‡Œçš„PIçš„KP
 806   3                  FOC_EKI = OBSW_KI_GAIN_RUN; // ä¼°ç®—å™¨é‡Œçš„PIçš„KI
 807   3                  //              GP07 = 1;
 808   3              }
 809   2              else if (mcFocCtrl.State_Count == 620) // 2000
 810   2              {
 811   3                  FOC_EKP = OBSW_KP_GAIN_RUN1; // ä¼°ç®—å™¨é‡Œçš„PIçš„KP
 812   3                  FOC_EKI = OBSW_KI_GAIN_RUN1; // ä¼°ç®—å™¨é‡Œçš„PIçš„KI
 813   3                  //              GP07 = 0;
 814   3              }
 815   2              else if (mcFocCtrl.State_Count == 580) // 1600
 816   2              {
 817   3                  FOC_EKP = OBSW_KP_GAIN_RUN2; // ä¼°ç®—å™¨é‡Œçš„PIçš„KP
 818   3                  FOC_EKI = OBSW_KI_GAIN_RUN2; // ä¼°ç®—å™¨é‡Œçš„PIçš„KI
 819   3                  //              GP07 = 1;
 820   3              }
 821   2              else if (mcFocCtrl.State_Count == 520) // 1200
 822   2              {
 823   3                  FOC_EKP = OBSW_KP_GAIN_RUN3; // ä¼°ç®—å™¨é‡Œçš„PIçš„KP
 824   3                  FOC_EKI = OBSW_KI_GAIN_RUN3; // ä¼°ç®—å™¨é‡Œçš„PIçš„KI
 825   3                  //              GP07 = 0;
 826   3              }
 827   2              else if (mcFocCtrl.State_Count == 480)
 828   2              {
 829   3                  FOC_EKP = OBSW_KP_GAIN_RUN4; // ä¼°ç®—å™¨é‡Œçš„PIçš„KP
 830   3                  FOC_EKI = OBSW_KI_GAIN_RUN4; // ä¼°ç®—å™¨é‡Œçš„PIçš„KI
 831   3                  //              GP07 = 1;
 832   3              }
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 15  

 833   2              else
 834   2                  ;
 835   2          }
 836   1      }
 837          
 838          /**
 839           * @brief    å¼±ç£æ§åˆ¶å‡½æ•°
 840           */
 841          void Weak_Control(void)
 842          {
 843   1          if (FOC__UQ > _Q15(0.7))
 844   1          {
 845   2              if (FOC_IDREF > WEAK_MAX)
 846   2              {
 847   3                  FOC_IDREF -= 1;
 848   3              }
 849   2              else
 850   2              {
 851   3                  FOC_IDREF = WEAK_MAX;
 852   3              }
 853   2          }
 854   1          else
 855   1          {
 856   2              FOC_IDREF = WEAK_MIN;
 857   2          }
 858   1      }
 859          
 860          /**
 861           * @brief    é»˜è®¤1mså‘¨æœŸæœåŠ¡å‡½æ•°ï¼Œè¿è¡Œä¿¡å·é‡‡æ ·ï¼Œè°ƒé€Ÿä¿¡å·å¤„ç†ï¼Œé—­ç¯æ§åˆ¶ï¼Œæ•…éšœ
             -æ£€æµ‹,ATOçˆ¬å¡å‡½æ•°
 862           *           è¯¥å‡½æ•°è¿è¡Œäºå¤§å¾ªç¯ä¸­ï¼Œç”±SYSTICKå®šæ—¶å™¨é—´éš”1msè§¦å‘è¿è¡Œã€‚
 863           */
 864          void TickCycle_1ms(void)
 865          {
 866   1          SetBit(ADC_CR, ADCBSY); // ä½¿èƒ½ADCçš„DCBUSé‡‡æ ·
 867   1          /* -----æ¯çº¿ç”µæµé‡‡æ ·----- */
 868   1          Power_Currt = (ADC3_DR << 3);
 869   1      
 870   1          if (Power_Currt > mcCurOffset.Iw_busOffset)
 871   1          {
 872   2              Power_Currt = Power_Currt - mcCurOffset.Iw_busOffset;
 873   2          }
 874   1          else
 875   1          {
 876   2              Power_Currt = 0;
 877   2          }
 878   1      
 879   1          /* -----æ¯çº¿ç”µæµæ»¤æ³¢----- */
 880   1          mcFocCtrl.mcADCCurrentbus = LPFFunction(Power_Currt, mcFocCtrl.mcADCCurrentbus, 32);
 881   1      
 882   1          /* -----è¾“å‡ºåŠŸç‡æ»¤æ³¢----- */
 883   1          if (mcState == mcRun)
 884   1          {
 885   2              mcFocCtrl.CurrentPower = FOC__POW << 3;
 886   2              mcFocCtrl.Powerlpf = LPFFunction(mcFocCtrl.CurrentPower, mcFocCtrl.Powerlpf, 10); // æ³¨æ„ä½é€šæ
             -»¤æ³¢å™¨ç³»æ•°èŒƒå›´ä¸º0---127
 887   2          }
 888   1      
 889   1          /* -----é€Ÿåº¦æ»¤æ³¢ã€åç”µåŠ¨åŠ¿æ»¤æ³¢----- */
 890   1          if ((mcState != mcInit) && (mcState != mcReady))
 891   1          {
 892   2              mcFocCtrl.SpeedFlt = LPFFunction(FOC__EOME, mcFocCtrl.SpeedFlt, 10); // æ³¨æ„ä½é€šæ»¤æ³¢å™¨ç³»æ•
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 16  

             -°èŒƒå›´ä¸º0---127
 893   2              mcFocCtrl.EsValue = LPFFunction(FOC__ESQU, mcFocCtrl.EsValue, 10);
 894   2          }
 895   1          else
 896   1          {
 897   2              mcFocCtrl.SpeedFlt = 0;
 898   2          }
 899   1      
 900   1          /* -----æ¯çº¿ç”µå‹çš„é‡‡æ ·å¹¶æ»¤æ³¢----- */
 901   1          AdcSampleValue.ADCDcbus = ADC2_DR;
 902   1          //        mcFocCtrl.mcDcbusFlt    = AdcSampleValue.ADCDcbus << 3;
 903   1          mcFocCtrl.mcDcbusFlt = LPFFunction((ADC2_DR << 3), mcFocCtrl.mcDcbusFlt, 80);
 904   1          /* -----åŠŸç‡è®¡ç®—----- */
 905   1          //        MDU_MUL_XDATA_U32(mcFocCtrl.mcADCCurrentbus, mcFocCtrl.mcDcbusFlt, &TempPower);
 906   1          //        mcFocCtrl.PowerCal = (uint16)(TempPower >> 11);
 907   1          //        mcFocCtrl.Powerlpf =  mcFocCtrl.PowerCal;
 908   1          /* -----ç¯è·¯å“åº”ï¼Œå¦‚é€Ÿåº¦ç¯ã€è½¬çŸ©ç¯ã€åŠŸç‡ç¯ç­‰----- */
 909   1          Speed_response();
 910   1      /* -----å¼±ç£åŠŸèƒ½é…ç½®----- */
 911   1      #if (WEAK_MAGNETIC_EN)
                  {
                      Weak_Control();
                  }
              #endif
 916   1          /* -----æ¸©åº¦çš„é‡‡æ ·å¹¶æ»¤æ³¢----- */
 917   1          mcFocCtrl.mcADCTemperature = LPFFunction((ADC7_DR << 3), mcFocCtrl.mcADCTemperature, 10);
 918   1          /* -----æ•…éšœä¿æŠ¤å‡½æ•°åŠŸèƒ½ï¼Œå¦‚è¿‡æ¬ å‹ä¿æŠ¤ã€å¯åŠ¨ä¿æŠ¤ã€ç¼ºç›¸ã€å µè½¬ç­‰----- */
 919   1          Fault_Detection();
 920   1      //        Fault_Overcurrent(&mcCurVarible);
 921   1      /* -----LEDç¯æ˜¾ç¤º----- */
 922   1      /* -----é€šè¿‡LEDç¯é—ªçƒçš„æ¬¡æ•°åé¦ˆé”™è¯¯çŠ¶æ€----- */
 923   1      //        LED_Display();
 924   1      /* -----å¯åœæµ‹è¯•çš„æ—¶å€™ä¸é€šè¿‡è°ƒé€Ÿæ–¹å¼ç»™å¼€å…³ä¿¡å·----- */
 925   1      /* -----ç”µæœºè°ƒé€Ÿæ¨¡å¼----- */
 926   1      #if (SPEED_MODE == PWMMODE) // PWMè°ƒé€Ÿæ¨¡å¼
                  {
                      /* -----PWMæ•è·å¤„ç†----- */
                      PWMInputCapture();
                  }
              #elif (SPEED_MODE == SREFMODE)
                  {
                      /* -----æ¨¡æ‹Ÿè°ƒé€Ÿ----- */
                      VSPSample();
                  }
              #elif (SPEED_MODE == NONEMODE) // ç›´æ¥ä¸Šç”µè¿è¡Œæ¨¡å¼
 937   1          {
 938   2              mcSpeedRamp.FlagONOFF = motor.state; // æ‰‹åŠ¨è®¾ç½®ä¸º0
 939   2      #if (Motor_Control_Mode == SPEED_LOOP_CONTROL)
 940   2              {
 941   3                  mcSpeedRamp.TargetValue = _Q15(motor.targetSpeed / MOTOR_SPEED_BASE); // ç”¨æˆ·è®¾ç½®è½¬é€Ÿ
 942   3              }
 943   2      #elif (Motor_Control_Mode == POWER_LOOP_CONTROL)
                      {
                          mcSpeedRamp.TargetValue = Motor_Min_Power;
                      }
              #elif (Motor_Control_Mode == CURRENT_LOOP_CONTROL)
                      {
                          mcSpeedRamp.TargetValue = Motor_Min_Current;
                      }
              #endif
 952   2          }
 953   1      #elif (SPEED_MODE == KEYMODE)
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 17  

                  {
                      /* -----æŒ‰é”®è°ƒé€Ÿ----- */
                      mcSpeedRamp.FlagONOFF = 1;
                      KeyScan();
                  }
              #elif (SPEED_MODE == ONOFFTEST)
                  {
                      if (mcFaultSource == FaultNoSource)
                      {
                          ONOFF_Starttest();
                      }
                  }
              #endif
 967   1      
 968   1          /* -----ç¡çœ æ¨¡å¼----- */
 969   1          //        Sleepmode();
 970   1      
 971   1          /* -----ç”µæœºçŠ¶æ€æœºçš„æ—¶åºå¤„ç†----- */
 972   1          if (mcFocCtrl.State_Count > 0)
 973   1          {
 974   2              mcFocCtrl.State_Count--;
 975   2          }
 976   1      
 977   1          if (BEMFDetect.BEMFTimeCount > 0)
 978   1          {
 979   2              BEMFDetect.BEMFTimeCount--;
 980   2          }
 981   1      
 982   1          if (RSDDetect.RSDCCWSBRCnt > 0)
 983   1          {
 984   2              RSDDetect.RSDCCWSBRCnt--;
 985   2          }
 986   1      
 987   1          if (mcFocCtrl.Brake_Count > 0)
 988   1          {
 989   2              mcFocCtrl.Brake_Count--;
 990   2          }
 991   1      
 992   1          if (mcSpeedRamp.MotorOnFilter > 0)
 993   1          {
 994   2              mcSpeedRamp.MotorOnFilter--;
 995   2          }
 996   1      
 997   1          if (mcSpeedRamp.MotorOffFilter > 0)
 998   1          {
 999   2              mcSpeedRamp.MotorOffFilter--;
1000   2          }
1001   1      
1002   1          /* -----ç”µæœºå¯åŠ¨çˆ¬å¡å‡½æ•°å¤„ç†----- */
1003   1          StarRampDealwith();
1004   1      
1005   1          /* -----è‡ªå®šä¹‰å‡½æ•°å…¥å£ ------*/
1006   1          MyTaskLoop();
1007   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2797    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    143      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.52.0.0   ADDFUNCTION                                                       04/01/2023 22:13:42 PAGE 18  

   IDATA SIZE       =     65       4
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
